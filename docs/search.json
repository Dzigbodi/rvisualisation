[
  {
    "objectID": "vizggplot.html",
    "href": "vizggplot.html",
    "title": "Visualisation: ggplot2",
    "section": "",
    "text": "Cette section aborde la visualisation ggplot2 dans R\nTout au long de cette section nous utiliserons deux bases de données: immigration et booking.\n\nlibrary(lubridate)\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(geojsonsf)\nlibrary(sf)\nPRdataset&lt;-read.csv(\"./data/ProvincePR.csv\")|&gt;\n           mutate(Date=as.Date(Date), Year=year(Date))|&gt;\n           group_by(Province, ProgramGroup, ProgramType,Year,Date)|&gt;\n          summarise(Value=sum(Value, na.rm=T), .groups = \"drop\")|&gt;\n          mutate(ProgramGroup=ifelse(ProgramGroup==\"Resettled Refugee &amp; Protected Person in Canada\",\"Refugee & Protected Person\",ProgramGroup),\n                 Group=recode(ProgramType,\n                 \"Business\"=\"Affaire\",\n                 \"Provincial Nominee Program\"=\"Programme Provincial\",\n                 \"Temporary Resident to Permanent Resident Pathway\"=\"Résidence temporaire\",\n                 \"Worker Program\"=\"Programme Travailleur\"\n               ))\n\nyeardataset&lt;-PRdataset|&gt;\n          group_by(Province, ProgramGroup, Group,Year)|&gt;\n          summarise(Value=sum(Value, na.rm=T), .groups = \"drop\")\n\nCandataset&lt;-PRdataset|&gt;\n            group_by(ProgramGroup, Group,Year)|&gt;\n          summarise(Value=sum(Value, na.rm=T), .groups = \"drop\")\n\nbooking&lt;-read.csv(\"./data/hotel_bookings.csv\")\n\n\n\nPour utiliser les fonctions de ggplot2 il faut d’abord l’installer install.packages(\"ggplot2\"). La grammaire d’un ggplot\nLe cadre de base d’un ggplot est ggplot(data, aes(x, y)) - data: prendre les données - aes(x,y): prendre les coordonnées à dessiner\n\n\n\nGraphique en surface (area band) Pour désiner un graphique en surface on ajoute geom_area(stat=\"bin\")\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))\np\n\n\n\n\n\np&lt;-p+\n  geom_area(stat=\"bin\", fill=\"blue\")\np\n\n\n\n\nggtitle() permat d’ajouter un titre au graphique. xlab() et ylab() permettent de donner des titres respectivement l’axe des abscisses et à l’axe des ordonnées.\n\np&lt;-p+ggtitle(\"Distribution des nombres des résidents permanents au Canada\")+\n   xlab(\"Nombre des immigrants\")+\n  ylab(\"Fréquence\")\np\n\n\n\n\n\nLe graphique des densités : geom_density() Pour dessiner un graphique des densités on utilise geom_density() et on précise le type de densité à utiliser.\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))+\n  geom_density(kernel=\"gaussian\")+\n  ylab(\"Densité\")+\n  xlab(\"Nombre des immigrants\")\np\n\n\n\n\n\nGraphique en points : geom_dotplot()\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))+\n  geom_dotplot(fill=\"red\")+ggtitle(\"Distribution des nombres des résidents permanents au Canada\")+\n   xlab(\"Nombre des immigrants\")+\n  ylab(\"Proprtion\")\n \np\n\n\n\n\n\nHistogramme Pour dessiner un histogramme, on utilise geom_histogram() en précisant le binwdith.\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))+\n  geom_histogram(stat=\"bin\", binwidth = 500, fill=\"red\")+ggtitle(\"Distribution des nombres des résidents permanents au Canada\")+\n   xlab(\"Nombre des immigrants\")+\n  ylab(\"Fréquence\")\n \np\n\n\n\n\n\n\n\nPour discrète, on peut dessiner une graphique en bar ou un camembert\n\nGraphique en bar\n\nPour dessiner un graphique en bar où on a une variable des labels et une variable des valeurs, on utilise geom_col() et coord_flip() pour changer les abscisses.\n\nbardataset&lt;-Candataset|&gt;filter(Year==2015, ProgramGroup==\"Economic\")\n\n\np&lt;-ggplot(bardataset, aes(x=Group, y=Value))+\n  geom_col()+coord_flip()+xlab(\"\")+ylab(\"Nombre d'immigrants\")\np\n\n\n\n\nOn peut aussi utiliser les geom_bar(). Dans ce cas nous n’avons pas besoin de deux variables catégories-valeurs\n\nbooking_2015&lt;-read.csv(\"./data/hotel_bookings.csv\")|&gt;\n        filter(arrival_date_year==2015, arrival_date_month==\"July\")\n\n\np&lt;-ggplot(booking_2015, aes(customer_type))+\n  geom_bar()\np\n\n\n\n\n\nGraphique en Camembert Avec geom_bar() et coord_polar() on peut dessiner un graphique en Camembert\n\n\np&lt;-ggplot(bardataset, aes(x=\"\", y=Value, fill=Group))+\n  geom_bar(stat=\"identity\", width=1, color=\"white\")+\n  coord_polar(\"y\", start=0)+\n  theme_void()\np\n\n\n\n\nPour enlever la légende on utilise theme(legend.position=\"none\")\n\nlabel_df&lt;-bardataset|&gt;\n        mutate(csum=rev(cumsum(rev(Value))),\n               pos=Value/2+lead(csum,1),\n               pos=if_else(is.na(pos),Value/2,pos))\n\np&lt;-ggplot(bardataset, aes(x=\"\", y=Value, fill=Group))+\n  geom_col( width=1, color=\"white\")+\n  coord_polar(\"y\", start=0)+\n  theme_void()+\n  theme(legend.position=\"none\")+\n  geom_text(data=label_df, aes(y = pos, label = paste(Group,\"\\n\", \"Valeur:\",formatC(Value, big.mark = \" \") )), color = \"white\", size=3,check_overlap = TRUE) +\n  scale_fill_brewer(palette=\"Set1\")\np\n\n\n\n\n\nAvec l’argument palette de la fonction scale_fill_brewer on peut choisir les différentes couleurs désirées:\n\nDivergente: BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral\nQualitative: Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3\nSequentielle: Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd\n\n\n\nL’utilisation de facet_wrap() La fonction facet_wrap() permet de dessiner séparément un même graphique selon un groupe de variable\n\n\nbardataset&lt;-Candataset|&gt;filter(ProgramGroup==\"Economic\")\n\np&lt;-ggplot(bardataset, aes(x=\"\", y=Value, fill=Group))+\n  geom_col(width=1, color=\"gray\")+\n  coord_polar(\"y\", start=0)+\n  theme_void()+\n  scale_fill_brewer(palette=\"Set3\")+\n   facet_wrap(~Year)+\n  labs(fill=\"PR Program\")\n \np\n\n\n\n\n\nBoite à moustache geom_boxplot()\n\n\nbardataset&lt;-Candataset|&gt;filter(ProgramGroup==\"Economic\")\n\nggplot(bardataset, aes(Group,Value))+geom_boxplot()+coord_flip()\n\n\n\n\n\n\n\n\nNuage de points avec geom_point()\n\n\nbardataset&lt;-Candataset|&gt;filter(ProgramGroup==\"Economic\")\np&lt;-ggplot(bardataset, aes(x=Year, y=Value, color=Group))+\n  geom_point()+\n  labs(color=\"\")+\n  theme(legend.position = \"bottom\")\np\n\n\n\n\n\ngraphique en line geom_line()\n\n\np&lt;-ggplot(bardataset, aes(x=Year, y=Value, color=Group))+\n  geom_line()\np\n\n\n\n\n\ngeom_line() avec facet_wrap()\n\n\np&lt;-ggplot(bardataset, aes(x=Year, y=Value ))+\n  geom_line()+\n  facet_wrap(~Group)\np\n\n\n\n\n\nAjouter une droite de regression\n\n\nPRdataset_mois&lt;-PRdataset|&gt;group_by(ProgramGroup, Year,Date)|&gt;\n          summarise(Value=sum(Value, na.rm=T), .groups = \"drop\")\n\n\np&lt;-ggplot(PRdataset_mois, aes(x=Date, y=Value ))+\n  geom_line()+\n  xlab(\"Date\")+\n  ylab(\"Nombre d'immigrants\")+\n  labs(title=\"La tendance des résidents permanents par type de programme\")+\n  facet_wrap(~ProgramGroup)+\n  geom_smooth()\np\n\n\n\n\n\nCartographie avec geom_sf()\n\nPour cet exemple, nous servirons de la librairie geojsonsf pour lire les fichier json en ligne.\nPour trouver les themes de ggpplot\n\nlong &lt;-unlist(map(proddata$geometry,1))\nlat &lt;- unlist(map(proddata$geometry,2))\npcan&lt;-ggplot(data=proddata)+geom_sf(aes(fill=Value))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n            ylim=c(min(lat)-50,max(lat)+200 ))+\n  labs(title=\"Immigration économique selon les Provinces\",\n       subtitle = \"2015\",\n       fill=\"Valeur\")+\n  theme_minimal()\n\npcan\n\n\n\n\nExemple du Togo sur l’éducation par région, nous utilisons le taux de non-scolarisation au Togo provenant des données de l’Unicef.\n\ntg_sf&lt;-geojson_sf(\"./data/tg-all.geo.json\")|&gt;\n  left_join(\ntibble(name=c(\"Maritime\",\"Plateaux\",\"Centre\",\"Kara\",\"Savanes\" ), primaire=c(4,6,6,16,15), secondaire=c(10,8,8,16,25), lycee=c(27,31,24,32,38)),\nby=\"name\")\n\n\ncoord&lt;-st_coordinates(tg_sf$geometry)\nlong &lt;-coord[,1]\nlat &lt;- coord[,2]\n#Taux de non-scolarisation (secondaire)\"\n#ggpubr::ggarrange(p1,p2,p3, ncol=3, widths = c(3, 3,3))\np1&lt;-ggplot(data=tg_sf)+geom_sf(aes(fill=primaire))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n           ylim=c(min(lat),max(lat)+200 ))+\n  labs(title=\"Taux de non-scolarisation\\nPrimaire\",\n       #subtitle = \"2021\",\n       fill=\"Taux(%)\")+\n  theme_minimal()\n\np2&lt;-ggplot(data=tg_sf)+geom_sf(aes(fill=secondaire))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n           ylim=c(min(lat),max(lat)+200 ))+\n  labs(title=\"Taux de non-scolarisation\\n Secondaire\",\n       fill=\"Taux(%)\")+\n  theme_minimal()\n\np3&lt;-ggplot(data=tg_sf)+geom_sf(aes(fill=lycee))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n           ylim=c(min(lat),max(lat)+200 ))+\n  labs(title=\"Taux de non-scolarisation\\nLycée\",\n       #subtitle = \"2021\",\n       fill=\"Taux(%)\")+\n  theme_minimal()\n\n\np1+p2+p3"
  },
  {
    "objectID": "vizggplot.html#ggplot2",
    "href": "vizggplot.html#ggplot2",
    "title": "Visualisation: ggplot2",
    "section": "",
    "text": "Pour utiliser les fonctions de ggplot2 il faut d’abord l’installer install.packages(\"ggplot2\"). La grammaire d’un ggplot\nLe cadre de base d’un ggplot est ggplot(data, aes(x, y)) - data: prendre les données - aes(x,y): prendre les coordonnées à dessiner\n\n\n\nGraphique en surface (area band) Pour désiner un graphique en surface on ajoute geom_area(stat=\"bin\")\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))\np\n\n\n\n\n\np&lt;-p+\n  geom_area(stat=\"bin\", fill=\"blue\")\np\n\n\n\n\nggtitle() permat d’ajouter un titre au graphique. xlab() et ylab() permettent de donner des titres respectivement l’axe des abscisses et à l’axe des ordonnées.\n\np&lt;-p+ggtitle(\"Distribution des nombres des résidents permanents au Canada\")+\n   xlab(\"Nombre des immigrants\")+\n  ylab(\"Fréquence\")\np\n\n\n\n\n\nLe graphique des densités : geom_density() Pour dessiner un graphique des densités on utilise geom_density() et on précise le type de densité à utiliser.\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))+\n  geom_density(kernel=\"gaussian\")+\n  ylab(\"Densité\")+\n  xlab(\"Nombre des immigrants\")\np\n\n\n\n\n\nGraphique en points : geom_dotplot()\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))+\n  geom_dotplot(fill=\"red\")+ggtitle(\"Distribution des nombres des résidents permanents au Canada\")+\n   xlab(\"Nombre des immigrants\")+\n  ylab(\"Proprtion\")\n \np\n\n\n\n\n\nHistogramme Pour dessiner un histogramme, on utilise geom_histogram() en précisant le binwdith.\n\n\np&lt;-ggplot(data=yeardataset, aes(Value))+\n  geom_histogram(stat=\"bin\", binwidth = 500, fill=\"red\")+ggtitle(\"Distribution des nombres des résidents permanents au Canada\")+\n   xlab(\"Nombre des immigrants\")+\n  ylab(\"Fréquence\")\n \np\n\n\n\n\n\n\n\nPour discrète, on peut dessiner une graphique en bar ou un camembert\n\nGraphique en bar\n\nPour dessiner un graphique en bar où on a une variable des labels et une variable des valeurs, on utilise geom_col() et coord_flip() pour changer les abscisses.\n\nbardataset&lt;-Candataset|&gt;filter(Year==2015, ProgramGroup==\"Economic\")\n\n\np&lt;-ggplot(bardataset, aes(x=Group, y=Value))+\n  geom_col()+coord_flip()+xlab(\"\")+ylab(\"Nombre d'immigrants\")\np\n\n\n\n\nOn peut aussi utiliser les geom_bar(). Dans ce cas nous n’avons pas besoin de deux variables catégories-valeurs\n\nbooking_2015&lt;-read.csv(\"./data/hotel_bookings.csv\")|&gt;\n        filter(arrival_date_year==2015, arrival_date_month==\"July\")\n\n\np&lt;-ggplot(booking_2015, aes(customer_type))+\n  geom_bar()\np\n\n\n\n\n\nGraphique en Camembert Avec geom_bar() et coord_polar() on peut dessiner un graphique en Camembert\n\n\np&lt;-ggplot(bardataset, aes(x=\"\", y=Value, fill=Group))+\n  geom_bar(stat=\"identity\", width=1, color=\"white\")+\n  coord_polar(\"y\", start=0)+\n  theme_void()\np\n\n\n\n\nPour enlever la légende on utilise theme(legend.position=\"none\")\n\nlabel_df&lt;-bardataset|&gt;\n        mutate(csum=rev(cumsum(rev(Value))),\n               pos=Value/2+lead(csum,1),\n               pos=if_else(is.na(pos),Value/2,pos))\n\np&lt;-ggplot(bardataset, aes(x=\"\", y=Value, fill=Group))+\n  geom_col( width=1, color=\"white\")+\n  coord_polar(\"y\", start=0)+\n  theme_void()+\n  theme(legend.position=\"none\")+\n  geom_text(data=label_df, aes(y = pos, label = paste(Group,\"\\n\", \"Valeur:\",formatC(Value, big.mark = \" \") )), color = \"white\", size=3,check_overlap = TRUE) +\n  scale_fill_brewer(palette=\"Set1\")\np\n\n\n\n\n\nAvec l’argument palette de la fonction scale_fill_brewer on peut choisir les différentes couleurs désirées:\n\nDivergente: BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral\nQualitative: Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3\nSequentielle: Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd\n\n\n\nL’utilisation de facet_wrap() La fonction facet_wrap() permet de dessiner séparément un même graphique selon un groupe de variable\n\n\nbardataset&lt;-Candataset|&gt;filter(ProgramGroup==\"Economic\")\n\np&lt;-ggplot(bardataset, aes(x=\"\", y=Value, fill=Group))+\n  geom_col(width=1, color=\"gray\")+\n  coord_polar(\"y\", start=0)+\n  theme_void()+\n  scale_fill_brewer(palette=\"Set3\")+\n   facet_wrap(~Year)+\n  labs(fill=\"PR Program\")\n \np\n\n\n\n\n\nBoite à moustache geom_boxplot()\n\n\nbardataset&lt;-Candataset|&gt;filter(ProgramGroup==\"Economic\")\n\nggplot(bardataset, aes(Group,Value))+geom_boxplot()+coord_flip()\n\n\n\n\n\n\n\n\nNuage de points avec geom_point()\n\n\nbardataset&lt;-Candataset|&gt;filter(ProgramGroup==\"Economic\")\np&lt;-ggplot(bardataset, aes(x=Year, y=Value, color=Group))+\n  geom_point()+\n  labs(color=\"\")+\n  theme(legend.position = \"bottom\")\np\n\n\n\n\n\ngraphique en line geom_line()\n\n\np&lt;-ggplot(bardataset, aes(x=Year, y=Value, color=Group))+\n  geom_line()\np\n\n\n\n\n\ngeom_line() avec facet_wrap()\n\n\np&lt;-ggplot(bardataset, aes(x=Year, y=Value ))+\n  geom_line()+\n  facet_wrap(~Group)\np\n\n\n\n\n\nAjouter une droite de regression\n\n\nPRdataset_mois&lt;-PRdataset|&gt;group_by(ProgramGroup, Year,Date)|&gt;\n          summarise(Value=sum(Value, na.rm=T), .groups = \"drop\")\n\n\np&lt;-ggplot(PRdataset_mois, aes(x=Date, y=Value ))+\n  geom_line()+\n  xlab(\"Date\")+\n  ylab(\"Nombre d'immigrants\")+\n  labs(title=\"La tendance des résidents permanents par type de programme\")+\n  facet_wrap(~ProgramGroup)+\n  geom_smooth()\np\n\n\n\n\n\nCartographie avec geom_sf()\n\nPour cet exemple, nous servirons de la librairie geojsonsf pour lire les fichier json en ligne.\nPour trouver les themes de ggpplot\n\nlong &lt;-unlist(map(proddata$geometry,1))\nlat &lt;- unlist(map(proddata$geometry,2))\npcan&lt;-ggplot(data=proddata)+geom_sf(aes(fill=Value))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n            ylim=c(min(lat)-50,max(lat)+200 ))+\n  labs(title=\"Immigration économique selon les Provinces\",\n       subtitle = \"2015\",\n       fill=\"Valeur\")+\n  theme_minimal()\n\npcan\n\n\n\n\nExemple du Togo sur l’éducation par région, nous utilisons le taux de non-scolarisation au Togo provenant des données de l’Unicef.\n\ntg_sf&lt;-geojson_sf(\"./data/tg-all.geo.json\")|&gt;\n  left_join(\ntibble(name=c(\"Maritime\",\"Plateaux\",\"Centre\",\"Kara\",\"Savanes\" ), primaire=c(4,6,6,16,15), secondaire=c(10,8,8,16,25), lycee=c(27,31,24,32,38)),\nby=\"name\")\n\n\ncoord&lt;-st_coordinates(tg_sf$geometry)\nlong &lt;-coord[,1]\nlat &lt;- coord[,2]\n#Taux de non-scolarisation (secondaire)\"\n#ggpubr::ggarrange(p1,p2,p3, ncol=3, widths = c(3, 3,3))\np1&lt;-ggplot(data=tg_sf)+geom_sf(aes(fill=primaire))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n           ylim=c(min(lat),max(lat)+200 ))+\n  labs(title=\"Taux de non-scolarisation\\nPrimaire\",\n       #subtitle = \"2021\",\n       fill=\"Taux(%)\")+\n  theme_minimal()\n\np2&lt;-ggplot(data=tg_sf)+geom_sf(aes(fill=secondaire))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n           ylim=c(min(lat),max(lat)+200 ))+\n  labs(title=\"Taux de non-scolarisation\\n Secondaire\",\n       fill=\"Taux(%)\")+\n  theme_minimal()\n\np3&lt;-ggplot(data=tg_sf)+geom_sf(aes(fill=lycee))+\n  coord_sf(xlim=c(min(long),max(long)+200 ),\n           ylim=c(min(lat),max(lat)+200 ))+\n  labs(title=\"Taux de non-scolarisation\\nLycée\",\n       #subtitle = \"2021\",\n       fill=\"Taux(%)\")+\n  theme_minimal()\n\n\np1+p2+p3"
  },
  {
    "objectID": "logical.html",
    "href": "logical.html",
    "title": "Base de la programmation",
    "section": "",
    "text": "Instruction if… else Cette instruction permet à l’utilisateur d’évaluer une condition. Si la condition est vraie, il y a une action qui s’exécute sinon l’action alternative s’exécute.\n\nPar exemple trouver si un entier naturel est divisible à la fois par 3 et par 5.\n\nx&lt;-15\n\nif(x %%5 ==0 & x%%3 ==0){\n  cat(\"Divisible par 3 et par 5\")\n}else{\n  cat(\"L'entier n'est ni divisible par 3 ni par 5\")\n}\n\nDivisible par 3 et par 5\n\n\n\nInstruction vectorielle ifelse() C’est la forme vectorielle de l’instruction if…else. Elle prend trois arguments: le premier évalue la condtion; le deuxième retourne le résultat si la condition est vraie et le troisième donne le résultat alternatif.\n\nPar exemple trouver les 100 premiers entiers naturels qui sont divisibles à la fois par 3 et par 5.\n\nx&lt;-1:100\nz&lt;-ifelse(x%%3==0 & x%%5==0, 1,0 )\nx[z==1]\n\n[1] 15 30 45 60 75 90\n\n\n\nInstruction conditionnelle switch C’est une instruction condition qui retourne les résultats selon le choix effectué. Le premier argument évalue le choix et retourne les résultats suivants ce choix.\n\n\nset.seed(123)\nx&lt;-rnorm(100)\ntype&lt;-\"sd\"\nz&lt;-switch(type,\n       mean=mean(x),\n       sd=sd(x))\nz\n\n[1] 0.9128159"
  },
  {
    "objectID": "logical.html#instructions-conditionnelles",
    "href": "logical.html#instructions-conditionnelles",
    "title": "Base de la programmation",
    "section": "",
    "text": "Instruction if… else Cette instruction permet à l’utilisateur d’évaluer une condition. Si la condition est vraie, il y a une action qui s’exécute sinon l’action alternative s’exécute.\n\nPar exemple trouver si un entier naturel est divisible à la fois par 3 et par 5.\n\nx&lt;-15\n\nif(x %%5 ==0 & x%%3 ==0){\n  cat(\"Divisible par 3 et par 5\")\n}else{\n  cat(\"L'entier n'est ni divisible par 3 ni par 5\")\n}\n\nDivisible par 3 et par 5\n\n\n\nInstruction vectorielle ifelse() C’est la forme vectorielle de l’instruction if…else. Elle prend trois arguments: le premier évalue la condtion; le deuxième retourne le résultat si la condition est vraie et le troisième donne le résultat alternatif.\n\nPar exemple trouver les 100 premiers entiers naturels qui sont divisibles à la fois par 3 et par 5.\n\nx&lt;-1:100\nz&lt;-ifelse(x%%3==0 & x%%5==0, 1,0 )\nx[z==1]\n\n[1] 15 30 45 60 75 90\n\n\n\nInstruction conditionnelle switch C’est une instruction condition qui retourne les résultats selon le choix effectué. Le premier argument évalue le choix et retourne les résultats suivants ce choix.\n\n\nset.seed(123)\nx&lt;-rnorm(100)\ntype&lt;-\"sd\"\nz&lt;-switch(type,\n       mean=mean(x),\n       sd=sd(x))\nz\n\n[1] 0.9128159"
  },
  {
    "objectID": "logical.html#instruction-itérative",
    "href": "logical.html#instruction-itérative",
    "title": "Base de la programmation",
    "section": "Instruction itérative",
    "text": "Instruction itérative\n\nLa boucle for Elle permet de réperter une instruction selon un certain nombre de fois. Reprenons notre exemple sur la divisibilité. Mais cette fois ci nous allos utiliser la boucle for\n\n\nx&lt;-1:100\nfor( i in x){\n  if( i%%3==0 & i%%5==0) cat(i, \" est divisible par 3 et par 5\",\"\\n\")\n}\n\n15  est divisible par 3 et par 5 \n30  est divisible par 3 et par 5 \n45  est divisible par 3 et par 5 \n60  est divisible par 3 et par 5 \n75  est divisible par 3 et par 5 \n90  est divisible par 3 et par 5 \n\n\n\nLa boucle while()\n\nC’est une instruction iterative qui répete une action tant que la condition d’entrée est vérifiée. Reprenons encore notre exemple de divisibilité, en utilisant la boucle while()\n\ni&lt;-1\nwhile(i&lt;=100){\n  if( i%%3==0 & i%%5==0) cat(i, \" est divisible par 3 et par 5\",\"\\n\")\n  i&lt;-i+1\n}\n\n15  est divisible par 3 et par 5 \n30  est divisible par 3 et par 5 \n45  est divisible par 3 et par 5 \n60  est divisible par 3 et par 5 \n75  est divisible par 3 et par 5 \n90  est divisible par 3 et par 5 \n\n\n\nLa boucle repeat C’est une instruction iterative qui est similiaire à la boucle while() à la différence qu’il faut préciser la condition d’arrêt à la fin en utilisant l’instruction break. Reprenons notre exemple de divisibilité.\n\n\ni&lt;-1\n\nrepeat{\n   if( i%%3==0 & i%%5==0) cat(i, \" est divisible par 3 et par 5\",\"\\n\")\n   i&lt;-i+1\n   if(i&gt;100) break\n  \n}\n\n15  est divisible par 3 et par 5 \n30  est divisible par 3 et par 5 \n45  est divisible par 3 et par 5 \n60  est divisible par 3 et par 5 \n75  est divisible par 3 et par 5 \n90  est divisible par 3 et par 5 \n\n\n\n\n\n\n\n\nExercice\n\n\n\nTrouver les nombre premiers inférieurs 100.\n\n\n\ni&lt;-1\nn&lt;-100\nrepeat{\n  \n  if(i&gt;1 & sum(i%%(2:(i))==0)==1) cat(i, \" est un nombre premier\", \"\\n\")\n   i&lt;-i+1\n\n  if(i&gt;n) break\n}\n\n2  est un nombre premier \n3  est un nombre premier \n5  est un nombre premier \n7  est un nombre premier \n11  est un nombre premier \n13  est un nombre premier \n17  est un nombre premier \n19  est un nombre premier \n23  est un nombre premier \n29  est un nombre premier \n31  est un nombre premier \n37  est un nombre premier \n41  est un nombre premier \n43  est un nombre premier \n47  est un nombre premier \n53  est un nombre premier \n59  est un nombre premier \n61  est un nombre premier \n67  est un nombre premier \n71  est un nombre premier \n73  est un nombre premier \n79  est un nombre premier \n83  est un nombre premier \n89  est un nombre premier \n97  est un nombre premier"
  },
  {
    "objectID": "logical.html#les-fonctions",
    "href": "logical.html#les-fonctions",
    "title": "Base de la programmation",
    "section": "Les fonctions",
    "text": "Les fonctions\nLes fonctions sont très utiles. Elles permettent de réduire les lignes de code en évitant des actions répétitives. Pour écrire une fonction on utilise l’instruction function(). Elle prend en entrée des variables et en sortie un résultat.\nReprenons l’exercice sur le nombre premier. Ecrivons une fonction qui retourne TRUE ou FALSE si le noombre est premier.\n\nest.premier&lt;-function(x){\n  premier&lt;-FALSE\n  if(x&gt;1 & sum(x%%(2:x)==0)==1){\n    premier&lt;-TRUE\n  }\n  return(premier)\n}\nest.premier(1)\n\n[1] FALSE\n\nest.premier(7)\n\n[1] TRUE\n\n\nUne fonction peut modifier une variable si elle a une portée globale. Dans la majeure des cas, les varaibles ont une portée locale. Pour modifier une variable d’une portée globale dans une fonction on utilise &lt;&lt;- dans l’assignation de la variable.\n\ny&lt;-0\nmodifier_y&lt;-function(x){\n  y&lt;&lt;-100\n  x&lt;-x+y\n  return(x)\n}\nmodifier_y(10)\n\n[1] 110"
  },
  {
    "objectID": "logical.html#vectoriser-une-fonction",
    "href": "logical.html#vectoriser-une-fonction",
    "title": "Base de la programmation",
    "section": "Vectoriser une fonction",
    "text": "Vectoriser une fonction\nIl est utile des fois de vectoriser une fonction pour éviter les boucles itératives. Pour vectoriser une fonction on utilise l’instruction Vectorize().\nReprenons notre fonction que nous avons écrire précédement, et vectorisons la. Puis affichons les nombres premiers inférieurs à 100.\n\nx&lt;-1:100\nEst.premier&lt;-Vectorize(function(x){\n  premier&lt;-FALSE\n  if(x&gt;1 & sum(x%%(2:x)==0)==1){\n    premier&lt;-TRUE\n  }\n  return(premier)\n})\n\nx[Est.premier(x)]\n\n [1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97\n\n\n\n\n\n\n\n\nExercice\n\n\n\nEcrire une fonction permet de vérifier si un nombre est à la fois divisible par 3 et 5. Puis vectoriser cette fonction, et trouver les entiers naturels inférieurs à 100 qui sont divisible par 3 et 5."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A propos",
    "section": "",
    "text": "Ce cours a pour but de fournir à l’apprenant des outils nécessaires pour maitriser la manipulation des données dans R et réaliser un tableau de bord intuitif.\nLes données pour ce cours se trouvent sur ce lien"
  },
  {
    "objectID": "exoggplot.html",
    "href": "exoggplot.html",
    "title": "Exercice Pratique ggplot2",
    "section": "",
    "text": "Lire le fichier sauvegardé lors de l’exercice sur dplyr. Dans la suite de cet exercice nous allons utiliser ce fichier.\n\n\nlibrary(tidyverse)\n\n\ndata_travail&lt;-read.csv(\"./data/exercice_dplyr.csv\")\n\n\nFiltrer la dernière année de la table fusionnée\n\n\ndata_travail_Dernier&lt;-data_travail|&gt;\n  filter(Annee==max(Annee))\n\n\nTracer l’histogramme des émissions de CO2 et du PIB Courant. Ajouter les titres et modifier les axes des abscisses et des ordornées.\n\n\nggplot(data=data_travail_Dernier, aes(Pibpercapita))+\n  geom_histogram(stat=\"bin\", bins = 35)+\n  labs(title=\"PIB courant par tête\",\n       subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       x=\"PIB per capita\",\n       y=\"Fréquence\")+\n  theme_minimal()\n\n\n\n\n\nggplot(data=data_travail_Dernier, aes(CO2percapita))+\n  geom_histogram(stat=\"bin\", bins = 35)+\n  labs(title=\"Émissions de CO2 par tête\",\n       subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       x=\"Émissions de CO2 per capita\",\n       y=\"Fréquence\")+\n  theme_minimal()\n\n\n\n\n\nTracer les diagrammes en moustache du PIB courant par tête par région économique\n\n\nggplot(data=data_travail_Dernier, aes(Income_group_Fr,Pibpercapita, color=Income_group_Fr))+geom_boxplot()+coord_flip()+\n  labs(title=\"PIB courant par tête\",\n        subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       y=\"\",\n       x=\"\",\n       color=\"\")+\n  theme_minimal()\n\n\n\n\n\nTracer les diagrammes en moustache du Émissions de CO2 par tête par région économique\n\n\nggplot(data=data_travail_Dernier, aes(Income_group_Fr,CO2percapita, color=Income_group_Fr))+geom_boxplot()+coord_flip()+\n  labs(title=\"Émissions de CO2 par tête\",\n        subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       y=\"\",\n       x=\"\",\n       color=\"\")+\n  theme_minimal()\n\n\n\n\n\n\nTracer les nuages de points l’émission de CO2 par tête en fonction du PIB par tête, en identifiant les groupes de revenu\n\n\n\nggplot(data=data_travail_Dernier, aes(x=Pibpercapita, y=CO2percapita, color=Income_group_Fr))+\n  geom_point()+\n  labs(title=\"Émissions de CO2 par tête en fonction du PIB par tête\",\n        subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       y=\"Émissions de CO2 per capita\",\n       x=\"PIB per capita\",\n       color=\"Groupe de revenu\"\n       )+\n  theme_light()\n\n\n\n\n\n\nAjouter un droite de regression sur les nuages de points: formula = 'y ~ x', se=T, color=\"red\", method=lm dans la fonction geom_smooth().\n\n\n\nggplot(data=data_travail_Dernier, aes(x=Pibpercapita, y=CO2percapita, color=Income_group_Fr))+\n  geom_point()+\n  geom_smooth(formula = 'y ~ x', se=T, color=\"red\", method=lm)+\n  labs(title=\"Émissions de CO2 par tête en fonction du PIB par tête\",\n        subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       y=\"Émissions de CO2 per capita\",\n       x=\"PIB per capita\",\n       color=\"Groupe de revenu\"\n       )+\n  theme_light()\n\n\n\n\n\n\nUtiliser la method de spline cubiques method = lm, formula = y ~ splines::bs(x, 3), se = T\n\n\n\nggplot(data=data_travail_Dernier, aes(x=Pibpercapita, y=CO2percapita, color=Income_group_Fr))+\n  geom_point()+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = T, color=\"red\")+\n  labs(title=\"Émissions de CO2 par tête en fonction du PIB par tête\",\n        subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       y=\"Émissions de CO2 per capita\",\n       x=\"PIB per capita\",\n       color=\"Groupe de revenu\"\n       )+\n  theme_light()\n\n\n\n\n\nUtiliser les données extraites en 2020, pour classer les pays selon le PIB par tête dans chaque groupe de revenu.\n\n\ndata_travail_Dernier&lt;-data_travail_Dernier|&gt;\n                      group_by(Income_group_Fr)|&gt;\n                      arrange(desc(Pibpercapita), .by_group = T)|&gt;\n                      mutate(Rank=1:n())|&gt;\n                     ungroup()\n\n\nUtiliser dans size=4, shape=1 dans la fonction geom_point().\n\n\np1&lt;-ggplot(data=data_travail_Dernier, aes(x=Pibpercapita, y=CO2percapita, color=Income_group_Fr))+\n  geom_point(size=4, shape=1)+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = T, color=\"red\")+\n  labs(title=\"Émissions de CO2 par tête en fonction du PIB par tête\",\n        subtitle = paste(\"Indicateurs du développement dans le monde,\", max(data_travail$Annee)),\n       y=\"Émissions de CO2 per capita\",\n       x=\"PIB per capita\",\n       color=\"Groupe de revenu\"\n       )+\n  theme_light()\np1\n\n\n\n\n\nAfficher le nom des pays sur le graphique\n\n\np2&lt;-p1+ geom_text(aes(label=Country_Name_Fr))\np2\n\n\n\n\n\nAfficher seulement les premiers pays émétteurs CO2 par groupe de revenu\n\n\np3&lt;-p1+geom_text(aes(label=Country_Name_Fr), color=\"gray20\",\n                 data=data_travail_Dernier|&gt;\n                   filter(Rank&lt;=5),check_overlap = TRUE)\np3\n\n\n\n\n\nUtiliser la fonction scale_x_continuous() pour délimiter l’axe des abscisses\n\n\np4&lt;-p3+scale_x_continuous(limits=c(-1000, 180000))\np4"
  },
  {
    "objectID": "creationselect.html",
    "href": "creationselect.html",
    "title": "Creation, fusion et manipulation",
    "section": "",
    "text": "Cette section introduit la manipulation des données dans R."
  },
  {
    "objectID": "creationselect.html#manipulation-des-données-avec-dplyr",
    "href": "creationselect.html#manipulation-des-données-avec-dplyr",
    "title": "Creation, fusion et manipulation",
    "section": "Manipulation des données avec dplyr",
    "text": "Manipulation des données avec dplyr\n\nCréation d’objet tibble()\ntibble() est une table de données équivalent à data.frame. Il fait partie de la libraire dplyr.\n\nlibrary(tidyverse)\nset.seed(100)\nn&lt;-10000\nProduits&lt;-tibble(Date=seq.Date(from=as.Date(\"1996/01/01\"), by=\"day\", length=n), Categories=sample(LETTERS,n, replace=T), Pays=sample(c(\"Chine\",\"Inde\",\"USA\",\"Canada\",\"Togo\",\"Cameroun\",\"Côte d'ivoire\", \"Mexique\"), n, replace=T),Prix=runif(n,min = 20, max=100 ),\n                 Quantite=runif(n, min=5, max=10000))\nhead(Produits,2)\n\n# A tibble: 2 × 5\n  Date       Categories Pays   Prix Quantite\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 1996-01-01 J          Inde   88.9    3479.\n2 1996-01-02 W          USA    84.0     449.\n\n\nLa fonction seq.Date() permet de créer les séquences de date.\n\n\nCréation ou transformation de variables: mutate()\nLa function mutate() permet de créer une variable ou de transformer une variable existante. Pour attacher les données à une fonction, on sert de l’instruction %&gt;% ou |&gt;. C’est comme si on écrivait: \\(f(x,y)\\), \\(x\\) étant le tibble ou le data.frame passé en argument. Utilisons la table de données Produits pour créer la valeur des produits\n\nProduits&lt;-Produits|&gt;\n          mutate(Valeur=Prix*Quantite)\nhead(Produits,2)\n\n# A tibble: 2 × 6\n  Date       Categories Pays   Prix Quantite  Valeur\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt; &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n1 1996-01-01 J          Inde   88.9    3479. 309367.\n2 1996-01-02 W          USA    84.0     449.  37737.\n\n\n\n\nCréer ou manipuler plusieurs variables à la fois: across()\nLa fonction mutate() combiner avec across() permet de manipuler plusieurs variables à la fois.\n\nProduits&lt;-Produits|&gt;\n         mutate(across(c(Prix, Quantite), \\(x) round(x, 0)))\nhead(Produits,2)\n\n# A tibble: 2 × 6\n  Date       Categories Pays   Prix Quantite  Valeur\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt; &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n1 1996-01-01 J          Inde     89     3479 309367.\n2 1996-01-02 W          USA      84      449  37737.\n\n\n\nAvec le package lubridate nous pouvons extraire les années: year(), les mois: month(), les trimestres: quarter()\n\n\nProduits&lt;-Produits|&gt;\n          mutate(Annee=year(Date),\n                 Mois=month(Date),\n                 Trimestre=quarter(Date))\n\n\n\nRenommer une variable: rename()\nPour renommer une variable on utilise la fonction rename(nouvelle_variable=ancienne_variable)\n\nhead(Produits_renom&lt;-Produits|&gt;rename(`Pays de provenance`=Pays),3)\n\n# A tibble: 3 × 9\n  Date       Categories `Pays de provenance`  Prix Quantite  Valeur Annee  Mois\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1996-01-01 J          Inde                    89     3479 309367.  1996     1\n2 1996-01-02 W          USA                     84      449  37737.  1996     1\n3 1996-01-03 F          Côte d'ivoire           26     5019 129072.  1996     1\n# ℹ 1 more variable: Trimestre &lt;int&gt;\n\n\n\n\nReordonner les variables: relocate()\nLa fonction relocate permet de réordornner les variables dans une table.\n\nProduits_relo&lt;-Produits|&gt;relocate(Date, Annee,Trimestre, Mois, Pays,Categories)\nhead(Produits_relo,3)\n\n# A tibble: 3 × 9\n  Date       Annee Trimestre  Mois Pays         Categories  Prix Quantite Valeur\n  &lt;date&gt;     &lt;dbl&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n1 1996-01-01  1996         1     1 Inde         J             89     3479 3.09e5\n2 1996-01-02  1996         1     1 USA          W             84      449 3.77e4\n3 1996-01-03  1996         1     1 Côte d'ivoi… F             26     5019 1.29e5\n\n\n\n\nSelectionner les variables: select()\nLa fonction select() permet de selectionner les variables\n\nProduits_valeur&lt;-Produits|&gt;select(Date, Pays,Categories,Valeur)\nhead(Produits_valeur,3)\n\n# A tibble: 3 × 4\n  Date       Pays          Categories  Valeur\n  &lt;date&gt;     &lt;chr&gt;         &lt;chr&gt;        &lt;dbl&gt;\n1 1996-01-01 Inde          J          309367.\n2 1996-01-02 USA           W           37737.\n3 1996-01-03 Côte d'ivoire F          129072.\n\n\nOn peut exclure les variables en utilisant la négation ! ou -.\n\nProduits_valeur&lt;-Produits|&gt;select(-c(Prix,Quantite))\nhead(Produits_valeur,3)\n\n# A tibble: 3 × 7\n  Date       Categories Pays           Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-01 J          Inde          309367.  1996     1         1\n2 1996-01-02 W          USA            37737.  1996     1         1\n3 1996-01-03 F          Côte d'ivoire 129072.  1996     1         1\n\n\n\n\nAutres fonctions applicables à la sélection\nLes fonctions contains() , ends_with(), starts_with(), num_range(prefic, ordre), all_of() et any_of().\n\nhead(Produits_cont&lt;-Produits|&gt;select(contains(\"p\")),5)\n\n# A tibble: 5 × 2\n  Pays           Prix\n  &lt;chr&gt;         &lt;dbl&gt;\n1 Inde             89\n2 USA              84\n3 Côte d'ivoire    26\n4 Chine            31\n5 Chine            78\n\n\n\n\nRecodification des variables: recode() et case_when(), case_match\nNous pouvons créer une variable par recodification en utilisant case_when().\n\nProduits&lt;-Produits|&gt;mutate(Continent=case_when(\n  Pays%in% c(\"Chine\",\"Inde\")~ \"Asie\",\n  Pays%in%c(\"USA\",\"Canada\",\"Mexique\")~\"Amerique\",\n  Pays%in%c(\"Togo\",\"Cameroun\",\"Côte d'ivoire\")~\"Afrique\"\n))\nhead(Produits,3)\n\n# A tibble: 3 × 10\n  Date       Categories Pays          Prix Quantite Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-01 J          Inde            89     3479 3.09e5  1996     1         1\n2 1996-01-02 W          USA             84      449 3.77e4  1996     1         1\n3 1996-01-03 F          Côte d'ivoi…    26     5019 1.29e5  1996     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\nL’utilisation de case_match()\n\nProduits&lt;-Produits|&gt;mutate(Continent=case_match(\n  Pays,\n   c(\"Chine\",\"Inde\")~ \"Asie\",\n c(\"USA\",\"Canada\",\"Mexique\")~\"Amerique\",\n  c(\"Togo\",\"Cameroun\",\"Côte d'ivoire\")~\"Afrique\"\n))\nhead(Produits,3)\n\n# A tibble: 3 × 10\n  Date       Categories Pays          Prix Quantite Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-01 J          Inde            89     3479 3.09e5  1996     1         1\n2 1996-01-02 W          USA             84      449 3.77e4  1996     1         1\n3 1996-01-03 F          Côte d'ivoi…    26     5019 1.29e5  1996     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\nOn peut aussi utiliser recode()\n\nProduits&lt;-Produits|&gt;mutate(Continent=recode(\n  Pays,\n\"Chine\"= \"Asie\",\n\"Inde\"=\"Asie\",\n\"USA\"=\"Amerique\",\n\"Canada\"=\"Amerique\",\n\"Togo\"=\"Afrique\",\n\"Cameroun\"=\"Afrique\",\n\"Côte d'Ivoire\"=\"Afrique\"\n))\nhead(Produits,3)\n\n# A tibble: 3 × 10\n  Date       Categories Pays          Prix Quantite Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-01 J          Inde            89     3479 3.09e5  1996     1         1\n2 1996-01-02 W          USA             84      449 3.77e4  1996     1         1\n3 1996-01-03 F          Côte d'ivoi…    26     5019 1.29e5  1996     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\n\n\n\n\n\n\nExercice\n\n\n\n\nRecoder la variable Categories en Classe_Categories suivant la regroupement ci-après:\n\nA-G: 1\nH-P: 2\nQ-T: 3\nU-Z: 4\n\nTransformer cette variable en format factor dont les libellés sont: “Bas de gamme”, “Moyen de gamme”, “Haut de gamme” ,“Prémium”\n\n\n\n\n\nManipulation des observations: filter() and slice()\nLa fonction filter() permet de filtrer les observations selon des critères données.\n\nProduits_Cat&lt;-Produits|&gt;filter(Categories%in%c(\"A\",\"B\",\"F\"))\nhead(Produits_Cat,5)\n\n# A tibble: 5 × 10\n  Date       Categories Pays          Prix Quantite Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-03 F          Côte d'ivoi…    26     5019 1.29e5  1996     1         1\n2 1996-01-12 F          Togo            91     3260 2.97e5  1996     1         1\n3 1996-01-15 F          Chine           58      673 3.89e4  1996     1         1\n4 1996-01-16 B          Chine           68     2994 2.03e5  1996     1         1\n5 1996-01-29 B          Cameroun        57     8683 4.97e5  1996     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\n\nProduits_min&lt;-Produits|&gt;filter(Prix==min(Prix))\nhead(Produits_min,5)\n\n# A tibble: 5 × 10\n  Date       Categories Pays          Prix Quantite Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-02-19 V          Canada          20     1588 3.25e4  1996     2         1\n2 1996-07-25 G          Chine           20     7664 1.55e5  1996     7         3\n3 1997-04-03 A          Canada          20     5407 1.09e5  1997     4         2\n4 1997-04-21 Y          Côte d'ivoi…    20     5572 1.12e5  1997     4         2\n5 1997-07-27 O          Chine           20     3034 6.08e4  1997     7         3\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\nLa fonction slice() permet de sélectionner les lignes d’observations en précisant les numéros de lignes.\n\n(Cinq_premieres_obs&lt;-Produits|&gt;slice(1:5))\n\n# A tibble: 5 × 10\n  Date       Categories Pays          Prix Quantite Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-01 J          Inde            89     3479 3.09e5  1996     1         1\n2 1996-01-02 W          USA             84      449 3.77e4  1996     1         1\n3 1996-01-03 F          Côte d'ivoi…    26     5019 1.29e5  1996     1         1\n4 1996-01-04 P          Chine           31      354 1.09e4  1996     1         1\n5 1996-01-05 S          Chine           78     7739 6.07e5  1996     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\nLa fonction slice_sample() permet de sélectionner aléatoirement les lignes d’observations. La synthaxe slice_sample(.data,...,n,prop,weight_by, replace=FALSE)\n\n(Produits_sample&lt;-Produits|&gt;slice_sample(n=10, replace=F))\n\n# A tibble: 10 × 10\n   Date       Categories Pays         Prix Quantite Valeur Annee  Mois Trimestre\n   &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n 1 2019-07-21 A          Togo           72      894 6.40e4  2019     7         3\n 2 2007-06-11 F          Canada         23     2057 4.81e4  2007     6         2\n 3 1999-08-01 L          Togo           72     1578 1.13e5  1999     8         3\n 4 2002-04-08 R          Mexique        47     8838 4.11e5  2002     4         2\n 5 2015-04-09 S          Canada         45     6497 2.89e5  2015     4         2\n 6 1996-08-14 E          Canada         78     3889 3.05e5  1996     8         3\n 7 2013-01-08 M          Côte d'ivo…    56     7591 4.28e5  2013     1         1\n 8 2016-08-04 V          Cameroun       37     2958 1.09e5  2016     8         3\n 9 2012-05-09 H          Inde           83     1267 1.05e5  2012     5         2\n10 2009-01-15 T          Canada         23     5809 1.31e5  2009     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\nNous pouvons faire une selection aléatoire proportionnelle selon une variable de taille\n\n(Produits_poids&lt;-Produits|&gt;slice_sample(n=10, weight_by = Valeur))\n\n# A tibble: 10 × 10\n   Date       Categories Pays         Prix Quantite Valeur Annee  Mois Trimestre\n   &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n 1 2009-09-02 Q          Togo           69     6551 4.51e5  2009     9         3\n 2 2014-03-28 E          Chine          90     7817 7.00e5  2014     3         1\n 3 2011-07-13 K          Côte d'ivo…    76     7562 5.73e5  2011     7         3\n 4 1997-07-01 I          Togo           91     9023 8.21e5  1997     7         3\n 5 2021-01-28 F          Inde           59     4388 2.58e5  2021     1         1\n 6 1996-06-13 E          Côte d'ivo…    94     9608 9.00e5  1996     6         2\n 7 2003-10-05 F          Mexique        51     2296 1.18e5  2003    10         4\n 8 2021-09-12 S          Cameroun      100     5800 5.77e5  2021     9         3\n 9 2016-08-08 O          Côte d'ivo…    38     4413 1.68e5  2016     8         3\n10 2021-02-02 I          Togo           55     9625 5.26e5  2021     2         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\nLa fonction distinct() permet d’éliminer les doublons dans la table des données.\n\nProduits_Cat_Pays&lt;-Produits|&gt;distinct(Categories, Pays)\nhead(Produits_Cat_Pays)\n\n# A tibble: 6 × 2\n  Categories Pays         \n  &lt;chr&gt;      &lt;chr&gt;        \n1 J          Inde         \n2 W          USA          \n3 F          Côte d'ivoire\n4 P          Chine        \n5 S          Chine        \n6 Y          Mexique      \n\n\n\n\nGrouper et ordonner les observations\nLa fonction group_by() permet de grouper les observations selon une liste de variables\n\nProduits_Pays&lt;-Produits|&gt;group_by(Pays)|&gt;slice(1:2)\nhead(Produits_Pays)\n\n# A tibble: 6 × 10\n# Groups:   Pays [3]\n  Date       Categories Pays      Prix Quantite  Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-07 Z          Cameroun    91      344  31228.  1996     1         1\n2 1996-01-10 W          Cameroun    21     8180 168668.  1996     1         1\n3 1996-01-08 N          Canada      28     5622 154938.  1996     1         1\n4 1996-01-22 R          Canada      35     5044 177428.  1996     1         1\n5 1996-01-04 P          Chine       31      354  10854.  1996     1         1\n6 1996-01-05 S          Chine       78     7739 607091.  1996     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\n\n\n\n\n\n\nExercice\n\n\n\nUtiliser la fonction slice_min() et slice_max(), avec pour critère la variable Valeur dans chaque catégorie\n\n\nLa fonction arrange() permet d’ordonner les observations selon une variable ou une liste de variable. Lorsqu’on l’utilise avec la group_by() on spécifie si le tri se fera par groupe en utilisant .by_group=TRUE\n\nProduits_ord&lt;-Produits|&gt;group_by(Pays,Categories)|&gt;\n                       arrange(Valeur, .by_group = TRUE)\nhead(Produits_ord)\n\n# A tibble: 6 × 10\n# Groups:   Pays, Categories [1]\n  Date       Categories Pays      Prix Quantite Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 2022-12-26 A          Cameroun    63      220 13900.  2022    12         4\n2 2000-09-18 A          Cameroun    20      869 17486.  2000     9         3\n3 2001-10-04 A          Cameroun    58      723 42166.  2001    10         4\n4 2009-03-16 A          Cameroun    87      501 43800.  2009     3         1\n5 2018-06-14 A          Cameroun    26     2183 57215.  2018     6         2\n6 1997-08-31 A          Cameroun    84      723 60427.  1997     8         3\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\nPour préciser l’ordre décroissante on utilise la fonction desc().\n\nProduits_ord&lt;-Produits|&gt;group_by(Pays,Categories)|&gt;\n                       arrange(desc(Valeur), .by_group = TRUE)\nhead(Produits_ord)\n\n# A tibble: 6 × 10\n# Groups:   Pays, Categories [1]\n  Date       Categories Pays      Prix Quantite  Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1997-08-30 A          Cameroun   100     9807 980638.  1997     8         3\n2 2006-04-06 A          Cameroun    93     9599 888097.  2006     4         2\n3 2017-05-19 A          Cameroun    96     7835 755798.  2017     5         2\n4 2004-04-03 A          Cameroun    98     6573 642084.  2004     4         2\n5 2021-02-26 A          Cameroun    64     9917 635315.  2021     2         1\n6 1996-10-10 A          Cameroun    94     6373 600292.  1996    10         4\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\n\n\nDescriptions des variables: summarise()\nLa fonction summarise() est appliquée aux colonnes pour créer une nouvelle table. Dans ce cas on peut utiliser les fonctions comme:\n\nFonction de comptage\n\nn(): nombre de valeurs ou de lignes\nn_distinct(): nombre unique\nsum(!is.na()): nombre de valeurs non manquantes\n\nFonction de positions\n\nmean(): moyenne\nmedian()\n\nFonction de rang\n\nquantile(): Nombre de quantile\nmin(): valeur minimum\nmax(): valeur maximum\n\nFonction de dispersion\n\nIQR(): interval inter-quartile\nmad(): Ecart médian absolu\nsd() : standard deviation\nvar(): variance\n\n\nPar ailleurs, l’utilisateur peut écrire sa fonction et la passer dans la fonction summarise().\n\nProduits|&gt;summarise(Valeur_Min=min(Valeur))\n\n# A tibble: 1 × 1\n  Valeur_Min\n       &lt;dbl&gt;\n1       169.\n\n\nLa fonction summarise peut être combinée aussi avec la fonction group_by().\n\nProduits|&gt;group_by(Pays)|&gt;summarise(Valeur_Max=max(Valeur))\n\n# A tibble: 8 × 2\n  Pays          Valeur_Max\n  &lt;chr&gt;              &lt;dbl&gt;\n1 Cameroun         990625.\n2 Canada           953725.\n3 Chine            959583.\n4 Côte d'ivoire    989122.\n5 Inde             949136.\n6 Mexique          966088.\n7 Togo             991773.\n8 USA              961566.\n\n\nUtiliser la fonction across() pour une application sur plusieurs variables\n\nProduits|&gt;group_by(Annee,Pays)|&gt;summarise(across(c(Prix, Quantite, Valeur),\\(x)min(x)), .groups = \"drop\")\n\n# A tibble: 224 × 5\n   Annee Pays           Prix Quantite Valeur\n   &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n 1  1996 Cameroun         21       86  6681.\n 2  1996 Canada           20      154  5941.\n 3  1996 Chine            20      354 10854.\n 4  1996 Côte d'ivoire    21      182  9681.\n 5  1996 Inde             21      163  4974.\n 6  1996 Mexique          23      132  3009.\n 7  1996 Togo             23        9   302.\n 8  1996 USA              25      179 11077.\n 9  1997 Cameroun         20      178 11433.\n10  1997 Canada           20       81  4575.\n# ℹ 214 more rows\n\n\nUtiliser la fonction across() avec une liste de fonctions\n\nProduits|&gt;group_by(Annee,Pays)|&gt;summarise(across(c(Prix, Quantite, Valeur),list(min=min, max=max, mean=mean)),.groups = \"drop\")\n\n# A tibble: 224 × 11\n   Annee Pays          Prix_min Prix_max Prix_mean Quantite_min Quantite_max\n   &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n 1  1996 Cameroun            21       99      61.4           86         9913\n 2  1996 Canada              20       98      57.7          154         9375\n 3  1996 Chine               20       98      55.4          354         9270\n 4  1996 Côte d'ivoire       21       99      65.2          182         9957\n 5  1996 Inde                21       99      53.4          163         9614\n 6  1996 Mexique             23      100      61.2          132         9846\n 7  1996 Togo                23       99      57.4            9         8837\n 8  1996 USA                 25       97      61.6          179         9791\n 9  1997 Cameroun            20      100      62.1          178         9946\n10  1997 Canada              20       99      65.5           81         9772\n# ℹ 214 more rows\n# ℹ 4 more variables: Quantite_mean &lt;dbl&gt;, Valeur_min &lt;dbl&gt;, Valeur_max &lt;dbl&gt;,\n#   Valeur_mean &lt;dbl&gt;"
  },
  {
    "objectID": "creationselect.html#combinaison-des-tables-de-données",
    "href": "creationselect.html#combinaison-des-tables-de-données",
    "title": "Creation, fusion et manipulation",
    "section": "Combinaison des tables de données",
    "text": "Combinaison des tables de données\nDans cette section, nous aborderons la fusion des tables et l’ajout des observations à une table.\n\nAjout d’observation de deux tables de données\nPour ajouter deux tables données, il faudra que les deux tables aient le même nombre de colonnes. On utilise pour cela la fonction bind_rows()\n\nProduits1&lt;-Produits|&gt;filter(Continent==\"Asie\")\nProduits2&lt;-Produits|&gt;filter(Continent!=\"Asie\")\n\nProduits_Rows&lt;-Produits1|&gt;bind_rows(Produits2)\n\nhead(Produits_Rows)\n\n# A tibble: 6 × 10\n  Date       Categories Pays   Prix Quantite  Valeur Annee  Mois Trimestre\n  &lt;date&gt;     &lt;chr&gt;      &lt;chr&gt; &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;int&gt;\n1 1996-01-01 J          Inde     89     3479 309367.  1996     1         1\n2 1996-01-04 P          Chine    31      354  10854.  1996     1         1\n3 1996-01-05 S          Chine    78     7739 607091.  1996     1         1\n4 1996-01-09 L          Inde     63      163  10285.  1996     1         1\n5 1996-01-13 D          Chine    31     5451 170341.  1996     1         1\n6 1996-01-15 F          Chine    58      673  38865.  1996     1         1\n# ℹ 1 more variable: Continent &lt;chr&gt;\n\n\n\n\nAjout de variables\nL’ajout de variables peut se faire par la fonction bind_cols() ou par fusion. Dans le cas de l’utilisation de la variable bind_cols(), il faut s’assurer que les lignes soient correspondantes.\nNous nous concentrons sur la fusion de données car c’est le cas le plus intéressant.\n\ninner_join() C’est une fonction qui permet de fusionner les élements communs de deux tables selon une clé de fusion.\n\n\nPrix_df&lt;-Prix|&gt;inner_join(dictionnaire, by=c(\"CODE\"=\"SERIE\"))\nhead(Prix_df,2)\n\n           CODE                                             SOURCE     Date\n1 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 2/1/2000\n2 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 3/1/2000\n  Prix          PAYS        COMMODITE\n1    0 GUINEE BISSAU 01--Alimentation\n2    0 GUINEE BISSAU 01--Alimentation\n\n\n\nleft_join() Soit deux tables A et B ayant une clé commune. Si on veut ramèner les observations qui de A qui sont dans B, on utilisera la fonction left_join() selon la clée\n\n\nPrix_df&lt;-Prix|&gt;left_join(dictionnaire, by=c(\"CODE\"=\"SERIE\"))\nhead(Prix_df,2)\n\n           CODE                                             SOURCE     Date\n1 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 2/1/2000\n2 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 3/1/2000\n  Prix          PAYS        COMMODITE\n1    0 GUINEE BISSAU 01--Alimentation\n2    0 GUINEE BISSAU 01--Alimentation\n\n\n\nright_join() C’est une fonction similaire à left_join(), mais danse que ramène les observations de B qui sont dans A.\n\n\nPrix_df&lt;-Prix|&gt;right_join(dictionnaire, by=c(\"CODE\"=\"SERIE\"))\nhead(Prix_df,2)\n\n           CODE                                             SOURCE     Date\n1 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 2/1/2000\n2 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 3/1/2000\n  Prix          PAYS        COMMODITE\n1    0 GUINEE BISSAU 01--Alimentation\n2    0 GUINEE BISSAU 01--Alimentation\n\n\n\nfull_join() La fonction full_join() de retenir toutes les observations des deux tables.\n\n\nPrix_df&lt;-Prix|&gt;full_join(dictionnaire, by=c(\"CODE\"=\"SERIE\"))\nhead(Prix_df,2)\n\n           CODE                                             SOURCE     Date\n1 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 2/1/2000\n2 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 3/1/2000\n  Prix          PAYS        COMMODITE\n1    0 GUINEE BISSAU 01--Alimentation\n2    0 GUINEE BISSAU 01--Alimentation\n\n\n\nanti_join() La fonction anti_join() de retenir uniquement les observations de A qui ne sont pas dans B.\nRemodeler les données : gather() et spread()\n\nspread() permet de créer de variables à partir d’une colonne clé et d’une colonne valeur.\n\nProduits_Agg&lt;-Produits|&gt;\n              group_by(Annee, Pays)|&gt;\n              summarise(Valeur=sum(Valeur), .groups=\"drop\")\n\n\n(Produits_court&lt;-Produits_Agg|&gt;\n          spread(key=Pays, value=Valeur))\n\n# A tibble: 28 × 9\n   Annee  Cameroun    Canada  Chine `Côte d'ivoire`   Inde Mexique   Togo    USA\n   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;           &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1  1996 10766168. 14105510. 1.19e7       21234381. 1.42e7  1.15e7 9.15e6 1.37e7\n 2  1997 14662885. 11541927. 1.40e7       15793027. 1.71e7  1.54e7 7.24e6 1.39e7\n 3  1998  9382640. 14095486. 1.71e7       17538154. 1.51e7  8.40e6 1.12e7 1.10e7\n 4  1999 11691493. 13602121. 1.23e7       16060310. 1.06e7  1.43e7 1.08e7 1.56e7\n 5  2000 12700349. 13877628. 1.95e7       10826477. 1.16e7  1.57e7 8.95e6 1.52e7\n 6  2001 12797004. 14488223. 1.31e7       16095095. 1.12e7  1.62e7 1.07e7 9.01e6\n 7  2002 11880047. 15181935. 1.44e7       16124581. 1.39e7  1.43e7 1.56e7 1.31e7\n 8  2003 12477949.  9706718. 1.21e7       15775635. 1.13e7  1.72e7 1.21e7 1.66e7\n 9  2004  8925461. 13422328. 1.21e7       11366224. 1.53e7  1.38e7 1.49e7 1.81e7\n10  2005 11814168. 10761638. 1.52e7       12845589. 1.03e7  1.39e7 2.06e7 1.28e7\n# ℹ 18 more rows\n\n\ngather() prend plusieurs colonnes et le transforme en deux colonnes de clé-valeur\n\n(Products_long&lt;-Produits_court|&gt;gather(key=\"Pays\", \n                                              value=\"valeur\",\n                                              -Annee))\n\n# A tibble: 224 × 3\n   Annee Pays        valeur\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  1996 Cameroun 10766168.\n 2  1997 Cameroun 14662885.\n 3  1998 Cameroun  9382640.\n 4  1999 Cameroun 11691493.\n 5  2000 Cameroun 12700349.\n 6  2001 Cameroun 12797004.\n 7  2002 Cameroun 11880047.\n 8  2003 Cameroun 12477949.\n 9  2004 Cameroun  8925461.\n10  2005 Cameroun 11814168.\n# ℹ 214 more rows\n\n\n\n\nL’utilisation de pivot_longer() et de pivot_wider()\npivot_longer() et pivot_wider() fonctionnent exactement comme gather et spread()\n\n(Products_Pays_long&lt;-Produits_court|&gt;pivot_longer(!Annee, names_to=\"Pays\", values_to=\"Valeur\"))\n\n# A tibble: 224 × 3\n   Annee Pays             Valeur\n   &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;\n 1  1996 Cameroun      10766168.\n 2  1996 Canada        14105510.\n 3  1996 Chine         11856274.\n 4  1996 Côte d'ivoire 21234381.\n 5  1996 Inde          14152636.\n 6  1996 Mexique       11506933.\n 7  1996 Togo           9145886.\n 8  1996 USA           13740810.\n 9  1997 Cameroun      14662885.\n10  1997 Canada        11541927.\n# ℹ 214 more rows\n\n\n\n(Products_Pays_wide&lt;-Products_Pays_long|&gt;pivot_wider(names_from=Pays, values_from=Valeur))\n\n# A tibble: 28 × 9\n   Annee  Cameroun    Canada  Chine `Côte d'ivoire`   Inde Mexique   Togo    USA\n   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;           &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1  1996 10766168. 14105510. 1.19e7       21234381. 1.42e7  1.15e7 9.15e6 1.37e7\n 2  1997 14662885. 11541927. 1.40e7       15793027. 1.71e7  1.54e7 7.24e6 1.39e7\n 3  1998  9382640. 14095486. 1.71e7       17538154. 1.51e7  8.40e6 1.12e7 1.10e7\n 4  1999 11691493. 13602121. 1.23e7       16060310. 1.06e7  1.43e7 1.08e7 1.56e7\n 5  2000 12700349. 13877628. 1.95e7       10826477. 1.16e7  1.57e7 8.95e6 1.52e7\n 6  2001 12797004. 14488223. 1.31e7       16095095. 1.12e7  1.62e7 1.07e7 9.01e6\n 7  2002 11880047. 15181935. 1.44e7       16124581. 1.39e7  1.43e7 1.56e7 1.31e7\n 8  2003 12477949.  9706718. 1.21e7       15775635. 1.13e7  1.72e7 1.21e7 1.66e7\n 9  2004  8925461. 13422328. 1.21e7       11366224. 1.53e7  1.38e7 1.49e7 1.81e7\n10  2005 11814168. 10761638. 1.52e7       12845589. 1.03e7  1.39e7 2.06e7 1.28e7\n# ℹ 18 more rows"
  },
  {
    "objectID": "creationselect.html#manipulation-des-chaines-de-caractères",
    "href": "creationselect.html#manipulation-des-chaines-de-caractères",
    "title": "Creation, fusion et manipulation",
    "section": "Manipulation des chaines de caractères",
    "text": "Manipulation des chaines de caractères\n\nManipulation des chaines de caractères\nDans cette section nous aborderons les fonctions suivantes: - grep() et grepl(): La fonction grep() recherche les correspondances d’une expression régulière dans un vecteur de chaines de caractères. Elle retourne l’indice du caractère dans le vecteur.\n\nx&lt;-c(\"R\",\"est\",\"l'outil\",\"des\",\"scientiques\",\"des données\")\ngrep(\"[t-z]\",x)\n\n[1] 2 3 5\n\n\nLa fonction grepl() est similaire à grep() mais retourne des vecteurs logiques.\n\ngrepl(\"[t-z]\",x)\n\n[1] FALSE  TRUE  TRUE FALSE  TRUE FALSE\n\n\n\nregexpr() et gregexpr()\n\nLa fonction regexpr() recherche une chaine de caractères dans un text et retourne un vecteur comprenant renseignant la longueur de la chaine contenant l’élément recherché. Si la chaine n’est pas trouvée, elle retourne -1.\n\nregexpr(\"es\", x)\n\n[1] -1  1 -1  2 10  2\nattr(,\"match.length\")\n[1] -1  2 -1  2  2  2\n\n\nLa fonction gregexpr() retourne une liste comprenant renseignant la longueur de la chaine contenant l’élément recherché. Si la chaine n’est pas trouvée, elle retourne -1.\n\ngregexpr(\"es\", x)[[1]]\n\n[1] -1\nattr(,\"match.length\")\n[1] -1\n\n\n\nsub() et gsub() La fonction sub() substitue un caractère ou chaine de caractére par un autre défini par l’utilisateur. Mais s’il y a plusieurs caratères à trouver, elle ne remplace que le premier\n\n\ndate&lt;-\"17 12 2023\"\nsub(\"\\\\s\", \"-\", date)\n\n[1] \"17-12 2023\"\n\n\nLa fonction gsub() par contre remplace tous les caractères à trouver.\n\ndate&lt;-\"17 12 2023\"\ngsub(\"\\\\s\", \"-\", date)\n\n[1] \"17-12-2023\"\n\n\n\nregexec()\n\nregexec() renvoie une liste de la même longueur que le texte. Les éléments sont soit -1 si le caractère recherché n’a pas de correspondant ou soit une séquence d’entiers avec la positions de départ du caractère retrouvé et toutes les sous-chaînes correspondant aux sous-expressions entre parenthèses.\n\nx&lt;-\"https://regex101.com/\"\nr&lt;-regexec(\"(([^:]+)://)?([^:/]+)\",x )\nr\n\n[[1]]\n[1] 1 1 1 9\nattr(,\"match.length\")\n[1] 20  8  5 12\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n\n\n\nExpressions régulières\nJe vous invite à consulter de temps en temps le site regex si vous êtes bloqués.\n\nUtilisation de l’extraction par groupe avec les fonctions str_match et str_extract\n\n\n\nExemple\n\nstrings &lt;- c(\" 219 733 8965\", \"329-293-8753 \", \"banana\", \"595 794 7569\",\n  \"387 287 6718\", \"apple\", \"233.398.9187  \", \"482 952 3315\",\n  \"239 923 8115 and 842 566 4692\", \"Work: 579-499-7527\", \"$1000\",\n  \"Home: 543.355.3679\")\nphone &lt;- \"(\\\\d{3})[- .](\\\\d{3})[- .](\\\\d{4})\"\n\n\n\nstr_match\n\nstr_match(strings, phone)\n\n      [,1]           [,2]  [,3]  [,4]  \n [1,] \"219 733 8965\" \"219\" \"733\" \"8965\"\n [2,] \"329-293-8753\" \"329\" \"293\" \"8753\"\n [3,] NA             NA    NA    NA    \n [4,] \"595 794 7569\" \"595\" \"794\" \"7569\"\n [5,] \"387 287 6718\" \"387\" \"287\" \"6718\"\n [6,] NA             NA    NA    NA    \n [7,] \"233.398.9187\" \"233\" \"398\" \"9187\"\n [8,] \"482 952 3315\" \"482\" \"952\" \"3315\"\n [9,] \"239 923 8115\" \"239\" \"923\" \"8115\"\n[10,] \"579-499-7527\" \"579\" \"499\" \"7527\"\n[11,] NA             NA    NA    NA    \n[12,] \"543.355.3679\" \"543\" \"355\" \"3679\"\n\n\n\n\nstr_extract\n\nstr_extract(strings, phone)\n\n [1] \"219 733 8965\" \"329-293-8753\" NA             \"595 794 7569\" \"387 287 6718\"\n [6] NA             \"233.398.9187\" \"482 952 3315\" \"239 923 8115\" \"579-499-7527\"\n[11] NA             \"543.355.3679\"\n\n\n\n\nMatch en groupe\n\nphone&lt;-\"(?&lt;zone&gt;\\\\d{3})[- .](?&lt;phone&gt;\\\\d{3}[- .]\\\\d{4})\"\nstr_match(strings, phone)\n\n                     zone  phone     \n [1,] \"219 733 8965\" \"219\" \"733 8965\"\n [2,] \"329-293-8753\" \"329\" \"293-8753\"\n [3,] NA             NA    NA        \n [4,] \"595 794 7569\" \"595\" \"794 7569\"\n [5,] \"387 287 6718\" \"387\" \"287 6718\"\n [6,] NA             NA    NA        \n [7,] \"233.398.9187\" \"233\" \"398.9187\"\n [8,] \"482 952 3315\" \"482\" \"952 3315\"\n [9,] \"239 923 8115\" \"239\" \"923 8115\"\n[10,] \"579-499-7527\" \"579\" \"499-7527\"\n[11,] NA             NA    NA        \n[12,] \"543.355.3679\" \"543\" \"355.3679\"\n\n\n\n\n\n\n\n\nExercice\n\n\n\nNous allons dans cet exercice manipuler les données l’immigration Canada relative aux résidents permanents. Travail à faire: - Importer ce fichier suivant “https://www.ircc.canada.ca/opendata-donneesouvertes/data/EN_ODP-PR-ProvImmCat.xlsx”\n\nQu’est ce que vous remarquez?\nUtiliser la fonction str_remove_all() pour enlever cette chaine de caractère ‘xml:space=“preserve”&gt;’\nUtiliser la fonction select() avec where() pour retenir les colonnes pertinentes - Utiliser la fonction mutate() pour créer une ligne de contenant les dates.\nDefinir la lignes des dates comme variables\nUtiliser la fonction mutate() pour imputer les variables manquantes."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A propos",
    "section": "",
    "text": "Ce cours a pour but de fournir à l’apprenant des outils nécessaires pour maitriser la manipulation des données dans R et réaliser un tableau de bord intuitif."
  },
  {
    "objectID": "dplyrexercice.html",
    "href": "dplyrexercice.html",
    "title": "Exercice sur dplyr",
    "section": "",
    "text": "Cet exercice a pour but d’utiliser vos compétences aquises lors du cours sur la manipulation des données avec dplyr.\nDans cet exercice nous allons utiliser les données des Indicateurs du développement dans le monde. Les données concernent les Émissions de CO2 (tonnes métriques par habitant).\n\nlibrary(tidyverse)\n\n\nImporter le fichier des émissions de CO2. Noter bien que le fichier en format csv, mais le séparateur est ;, et le séparateur de décimal est “,”.\n\n\nCO2Emission&lt;-read.csv(\"./data/CO2Emission.csv\", sep=\";\", dec=\",\")\n\n\nUtiliser la fonction gather() pour créer une variable contenant les années et une autre contenant les valeurs.\n\n\nCO2Emission&lt;-CO2Emission|&gt;gather(key=\"Annee\", value = \"CO2percapita\", -Country_Code)\n\n\nQue remarquez-vous?\nUtiliser la fonction substr() pour extraire les années et les convertir en entier.\n\n\nCO2Emission&lt;-CO2Emission|&gt;mutate(Annee=substr(Annee,2,5),\n                                 Annee=as.integer(Annee))\n\n\nEnlever les valeur manquante des données\n\n\nCO2Emission&lt;-CO2Emission|&gt;filter(!is.na(CO2percapita))\n\n\n\nMaintenant importer le ficher des métadonnées\n\n\n\nMetadata&lt;-read.csv(\"./data/Metadata.csv\", sep=\";\", dec=\",\")\n\n\nImporter également le PIB courant percapita\n\n\nPibCourant&lt;-read.csv(\"./data/PIBpercapita.csv\", sep=\";\", dec=\",\")\n\n\nRépéter les questions 2 et 3\n\n\nPibCourant&lt;-PibCourant|&gt;gather(key=\"Annee\", value = \"Pibpercapita\", -Country_Code)\nPibCourant&lt;-PibCourant|&gt;mutate(Annee=substr(Annee,2,5),\n                                 Annee=as.integer(Annee))\nPibCourant&lt;-PibCourant|&gt;filter(!is.na(Pibpercapita))\n\n\nFusion des données. Fusionner les trois bases de données conformément aux informations de la métadonnée. Filtrer selon la variable Année supérieure ou égale à 2000.\n\n\ndata_travail&lt;-inner_join(PibCourant,CO2Emission, by=c(\"Country_Code\",\"Annee\"))|&gt;\n               right_join(Metadata, by=\"Country_Code\")|&gt;\n  filter(Annee&gt;=2000)\n\n\nEnlever les variables en anglais\n\n\ndata_travail&lt;-data_travail|&gt;select(!ends_with(\"_En\"))\n\n\nSauvegarder les données data_travail sous “./data/exercice_dplyr.csv”\n\n\nwrite.csv(data_travail,\"./data/exercice_dplyr.csv\", row.names = F)"
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "Lecture des données dans R",
    "section": "",
    "text": "Dans ce module introduit la lecture des connées dans R."
  },
  {
    "objectID": "import.html#importation-des-données",
    "href": "import.html#importation-des-données",
    "title": "Lecture des données dans R",
    "section": "Importation des données",
    "text": "Importation des données\n\nImporter un ficher txt\nPour importer un fichier txt on utilise les fonctions suivantes: - read.table() - read.delimit() Dans cet exemple, nous allons importer l’indice des prix à la consommation. Noter que le séparateur c’est une tabulation (sep=\"\\t\"), et la première ligne correspond au nom des variables (header=TRUE).\n\nPrix&lt;-read.table(\"./data/Prix.txt\", sep=\"\\t\", header = TRUE)\n\n\nhead(Prix,2)\n\n           CODE                                             SOURCE     Date\n1 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 2/1/2000\n2 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 3/1/2000\n  Prix\n1    0\n2    0\n\n\nAvec la fonction read.delim() nous allons importer les dictionnaire des données\n\ndictionnaire&lt;-read.delim(\"./data/Dictionnaire.txt\", sep = \"\\t\", header = TRUE)\n\n\nhead(dictionnaire,2)\n\n          SERIE          PAYS                                      COMMODITE\n1 AAASR3021M0BP COTE D'IVOIRE                               01--Alimentation\n2 AAASR3050M0BP COTE D'IVOIRE 02--Boissons alcoolisees, Tabac et stupefiants\n\n\n\n\nImporter un ficher csv\nOn uilise la fonction read.csv() pour importer les fichiers csv. Nous reprenons les mêmes données dans un format csv.\n\nPrix&lt;-read.csv(\"./data/Prix.csv\")\n\n\nhead(Prix,2)\n\n           CODE                                             SOURCE     Date\n1 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 2/1/2000\n2 SSSSR3021M0BP Institut National de la Statistique, Base 100=2014 3/1/2000\n  Prix\n1    0\n2    0\n\n\n\n\nImporter un ficher xlsx\nPour importer les fichierx xlsx nous nous servons de la librairie openxlsx. Dans cette libraire, la fonction read.xlsx() permet l’importation un fichier Excel.\n\nlibrary(openxlsx)\nPR&lt;-read.xlsx(xlsxFile = \"./data/Immigration.xlsx\", sheet = \"Immigration\")\n\n\nhead(PR,2)\n\n  CountryofCitizenship  Date Value   name Code      subregion continent\n1     French Polynesia 42005    NA France  FRA Western Europe    Europe\n2     French Polynesia 42036    NA France  FRA Western Europe    Europe\n\n\nNous pouvons également préciser les plages de cellules à importer en utilisant namedRegion.\n\nPR&lt;-read.xlsx(xlsxFile = \"./data/Immigration.xlsx\",  namedRegion= \"PR\")\nhead(PR,2)\n\n  CountryofCitizenship  Date Value   name Code      subregion continent\n1     French Polynesia 42005    NA France  FRA Western Europe    Europe\n2     French Polynesia 42036    NA France  FRA Western Europe    Europe"
  },
  {
    "objectID": "import.html#rappel-sur-les-format-date-et-factors",
    "href": "import.html#rappel-sur-les-format-date-et-factors",
    "title": "Lecture des données dans R",
    "section": "Rappel sur les format Date et factors",
    "text": "Rappel sur les format Date et factors\n\nFormat Date\n\n\nVariable catégorielle ou Nominale\n\nLa fonction factor() sert à créer une variable catégorielle\n\n\ngenre&lt;-factor(c(\"Masculin\",\"Féminin\",\"Masculin\",\"Masculin\",\"Féminin\",\"Féminin\",\"Féminin\"))\ngenre\n\n[1] Masculin Féminin  Masculin Masculin Féminin  Féminin  Féminin \nLevels: Féminin Masculin\n\n\n\nLa fonction levels() sert à définir les modalités.\n\n\nlevels(genre) \n\n[1] \"Féminin\"  \"Masculin\"\n\n\n\nPour labelliser une variable catégorielle\n\n\ngenre&lt;-c(1,1,1,2,2,1,2,1)\ngenre&lt;-factor(genre, levels=c(1,2), labels=c(\"Masculin\",\"Féminin\"))\ngenre\n\n[1] Masculin Masculin Masculin Féminin  Féminin  Masculin Féminin  Masculin\nLevels: Masculin Féminin\n\n\n\nLa fonction relevel() permet de redéfinir le label de référence (très utile pour les modèles logit)\n\n\nlevels(genre)\n\n[1] \"Masculin\" \"Féminin\" \n\ngenre&lt;-relevel(genre, ref=2)\nlevels(genre)\n\n[1] \"Féminin\"  \"Masculin\"\n\n\n\nLa fonction revalue() de la librairie plyr permet de recoder les labels,\n\n\nlevels(genre)\n\n[1] \"Féminin\"  \"Masculin\"\n\ngenre_r&lt;-plyr:: revalue(genre, c(\"Masculin\"=\"Homme\",\"Féminin\"=\"Femme\"))\nlevels(genre_r)\n\n[1] \"Femme\" \"Homme\""
  },
  {
    "objectID": "Intro.html",
    "href": "Intro.html",
    "title": "Rappel sur les Objets de R",
    "section": "",
    "text": "Dans ce module, nous allons parcourir les fondamentaux avec R à savoir: -Les notions de base dans R: operation, vecteur, dataframe, list. -Les fonctions prédéfinies dans la librairie de base R; -Introduction à la programmation dans R: structures conditionnelles, et les itérations, if, for, while, repeat - L’importation des fichiers de différents types: txt, xlsx, csv. - L’écriture des fichiers, en format rdata, rds, txt, xlsx, csv."
  },
  {
    "objectID": "Intro.html#installation-de-r",
    "href": "Intro.html#installation-de-r",
    "title": "Rappel sur les Objets de R",
    "section": "Installation de R",
    "text": "Installation de R\nR est un logiciel libre destiné aux calculs statistiques et graphiques du CRAN: Installer R à partir de Comprehensive R Archive Network.\n\nRStudio est un EDI (Environnement Intégré de Développement) adéquat pour R: Installer RStudio à partir du site posit.\nVous pouvez trouver comme alternatif à l’installation de R, des plateformes en ligne, parmi lesquels se trouvent:\n\nPosit Cloud\nkaggle\nrdrr.io\n\n\n\n\n\n\n\n\nTAF:\n\n\n\n\nAller sur https://posit.co/download/rstudio-desktop/\nChoisir la version compatible avec votre ordinateur\nTélécharger R et Rstudio.\nInstaller d’abord R, puis Rstudio"
  },
  {
    "objectID": "Intro.html#sec-démarrage-de-rstudio",
    "href": "Intro.html#sec-démarrage-de-rstudio",
    "title": "Rappel sur les Objets de R",
    "section": "Démarrage de Rstudio",
    "text": "Démarrage de Rstudio\nAu démarrage de Rstudio, vous verrez s’afficher la fenêtre ci-après.\n\n\nLes fenêtres: Console, Environnemnt, Script et help vont s’ouvrir par défaut.\nDans la console se comporte comme une calculatrice:\n\n\n    1+1 # addition \n\n[1] 2"
  },
  {
    "objectID": "Intro.html#operateurs-dassignition",
    "href": "Intro.html#operateurs-dassignition",
    "title": "Rappel sur les Objets de R",
    "section": "Operateurs d’assignition",
    "text": "Operateurs d’assignition\n\n\n\n\n\n\n\nOpération d’assignation\nSignification\n\n\n\n\n&lt;- ou encore (=)\nOpération d’affection\n\n\n&\nET\n\n\n|\nOU\n\n\n+, -, *,/\nAddition, soustraction, multiplication, division\n\n\n&gt;=, &lt;=, !=, ==\nSupérieur ou égal, inférieur ou égal, différent, égal\n\n\n$ , [[]]\nSélecteur de colonne dans un data.frame\n\n\n#\nCommentaire\n\n\n\nNous pouvons utilser la majeur partie de ces opérations sur les formats suivants: - Numérque (numeric) - Entier (integer) - Complexe - Logique (logic) - caractère (string)\n\necole&lt;-10\nclasse_par_ecole&lt;-15\ntotal_classe&lt;- ecole*classe_par_ecole\nprint(total_classe)\n\n[1] 150\n\n\n\n(ratio_ecole_classe&lt;-ecole/classe_par_ecole)\n\n[1] 0.6666667\n\n\n\n\n\n\n\n\nAttention:\n\n\n\nLe nom des variables dans R ne peuvent pas contenir les signes. Elles doivent commencer par les lettres de l’alphabet"
  },
  {
    "objectID": "Intro.html#les-statistiques-de-base-dans-r",
    "href": "Intro.html#les-statistiques-de-base-dans-r",
    "title": "Rappel sur les Objets de R",
    "section": "Les Statistiques de base dans R",
    "text": "Les Statistiques de base dans R\nR contient les fonctions pédéfinies, par exemples:\n\nprint(), cat(): sont des fonctions d’imprission.\ngetwd(): permet d’obtenir le répertoire de travail\nsetwd(): permet de définir le répertoire de travail\nls(): permet d’afficher la liste des objets\nrm(): permet de supprimer les objets dans l’espace de travail.\nsum(): somme, min(): minimum, max(): maximum, var(): variance, sd(): Ecart type.\nrnorm(), runif(), sample()\nsin(), cos()\nsummary(): pour décrire une variable.\n\n\n\n\n\n\n\nObtenir de l’aide\n\n\n\nEn entrant ? suivi de la fonction recherchée, vous pouvez avoir de l’aide sur cette fonction.\nVous pouvez utiliser library(help=\"base\") Pour voir la liste des fonctions qui sont prédéfines dans la version de base de R.\n\n\nExemple\n\ntheta&lt;-0.5*pi*rnorm(100)\nr&lt;-2\nx&lt;-r*cos(theta)\ny&lt;-r*sin(theta)\n\nDescription de x\n\nsummary(x)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-1.99993  0.02613  1.30072  0.76480  1.80208  1.99998 \n\n\nDescription de y\n\nsummary(y)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n-1.9913 -1.0911  0.1180  0.1154  1.3816  1.9988 \n\n\nListe des objets dans l’environnement\n\nls()\n\n[1] \"classe_par_ecole\"   \"ecole\"              \"has_annotations\"   \n[4] \"r\"                  \"ratio_ecole_classe\" \"theta\"             \n[7] \"total_classe\"       \"x\"                  \"y\""
  },
  {
    "objectID": "Intro.html#les-objets-de-r",
    "href": "Intro.html#les-objets-de-r",
    "title": "Rappel sur les Objets de R",
    "section": "Les Objets de R",
    "text": "Les Objets de R\nLes principaux objets de Rqui sont manipulables sont:\n\nLes vecteurs\nLes Matrices\nLes listes\nLes dataframes\n\n\nLes vecteurs\nPour créer un vecteur dans R, vous pouvez utiliser la fonction c() Par exemple un vecteur numérique\n\nx&lt;-c(1,2,3,8,10)\nprint(x)\n\n[1]  1  2  3  8 10\n\n\nUn vecteur de caractères\n\ny&lt;-c(\"Toto\",\"Ecole\",\"Classe\",\"Maison\")\nprint(y)\n\n[1] \"Toto\"   \"Ecole\"  \"Classe\" \"Maison\"\n\n\nUn vecteur logique\n\nz&lt;-c(T, F, T, F,F,T)\nprint(z)\n\n[1]  TRUE FALSE  TRUE FALSE FALSE  TRUE\n\n\nOn peut convertir un vecteur logique en format numérique: as.numeric()\n\nw&lt;-as.numeric(z)\nprint(w)\n\n[1] 1 0 1 0 0 1\n\n\n\n\n\n\n\n\nAttention:\n\n\n\nIl n’est pas possible d’associer un format numerique et un format caractère. Tout le contenu prendra le format caractère.\n\n\n\nt&lt;-c(\"Classe\", 1, \"Toto\", 3,8)\nprint(t)\n\n[1] \"Classe\" \"1\"      \"Toto\"   \"3\"      \"8\"     \n\n\nPar contre on peut convertir un vecteur numérique en caractère: as.character().\n\nu&lt;-as.character(x)\nprint(u)\n\n[1] \"1\"  \"2\"  \"3\"  \"8\"  \"10\"\n\n\n\n\nLes matrices\nUne matrice dans R se crée avec avec la fonction matrix() en précisant le nombre des colonnes et le nombre des lignes, les données.\n\nset.seed(100)\nm&lt;-matrix(rnorm(100), ncol=5, nrow=20)\nhead(m, 4)\n\n            [,1]       [,2]       [,3]        [,4]        [,5]\n[1,] -0.50219235 -0.4380900 -0.1016292 -0.26199577  0.89682227\n[2,]  0.13153117  0.7640606  1.4032035 -0.06884403 -0.04999577\n[3,] -0.07891709  0.2619613 -1.7767756 -0.37888356 -1.34534931\n[4,]  0.88678481  0.7734046  0.6228674  2.58195893 -1.93121153\n\n\nOn peut créer des matrices de caractères\n\nx&lt;-sample(letters, 100, replace=T)\nmc&lt;-matrix(x, ncol=5, nrow=20)\nhead(mc, 4)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"r\"  \"z\"  \"g\"  \"e\"  \"x\" \n[2,] \"a\"  \"j\"  \"n\"  \"t\"  \"k\" \n[3,] \"g\"  \"t\"  \"e\"  \"w\"  \"k\" \n[4,] \"j\"  \"o\"  \"l\"  \"h\"  \"s\" \n\n\nPour extraire des élements de la matrice, il suffit de préciser les indices lignes (i) et colonnes j: m[i,j]\n\nm[1,2]\n\n[1] -0.43809\n\n\n\nm[1:3, 1:5]\n\n            [,1]       [,2]       [,3]        [,4]        [,5]\n[1,] -0.50219235 -0.4380900 -0.1016292 -0.26199577  0.89682227\n[2,]  0.13153117  0.7640606  1.4032035 -0.06884403 -0.04999577\n[3,] -0.07891709  0.2619613 -1.7767756 -0.37888356 -1.34534931\n\n\nOn peut assigner les noms aux lignes et aux colonnes en utilisant row.names() et colnames()\n\nrow.names(m)&lt;-paste(\"r\", 1:nrow(m),sep=\".\")\ncolnames(m)&lt;-paste(\"c\", 1:ncol(m), sep=\".\")\nm[\"r.1\", \"c.1\"]\n\n[1] -0.5021924\n\n\nLes fonctions rbind() et cbind() peuvent aussi servir à créer une matrice. Elles permettent de combiner les vecteurs par ligne (rbind()) ou par colonne (cbind()).\n\n\n\n\n\n\nAttention:\n\n\n\nPour utiliser les fonctions rbind() et cbind(). Il faut s’assurer que les vecteurs soient de même dimension.\n\n\n\nv1&lt;-runif(5)\nv2&lt;-rnorm(5)\n(m1&lt;-cbind(v1, v2))\n\n            v1           v2\n[1,] 0.6179082 -0.242269499\n[2,] 0.6041435  0.059031382\n[3,] 0.7858796 -0.177271868\n[4,] 0.5552685  0.794680268\n[5,] 0.7689783  0.006737787\n\n(m2&lt;-rbind(v1, v2))\n\n         [,1]       [,2]       [,3]      [,4]        [,5]\nv1  0.6179082 0.60414349  0.7858796 0.5552685 0.768978339\nv2 -0.2422695 0.05903138 -0.1772719 0.7946803 0.006737787\n\n\n\n\n\nOpération matricielle\nSignification\n\n\n*\nMultiplication élément par élément\n\n\n%*%\nMultiplication matricielle\n\n\nt()\nTransposition de matrice\n\n\ndet()\ndéterminant d’une matrice\n\n\nsolve()\nInverse d’une matrice\n\n\n\n\n\nLes listes\nLes listes sont beaucoup utilisés dans R, et sont vraiment pratiques. Pour créer une liste on utilise la fonction list().\n\ny&lt;-list(1,2)\ny\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n\nOn peut aussi imbriquer les listes\n\ny&lt;-list(1, list(T, list(c(1:4))))\ny\n\n[[1]]\n[1] 1\n\n[[2]]\n[[2]][[1]]\n[1] TRUE\n\n[[2]][[2]]\n[[2]][[2]][[1]]\n[1] 1 2 3 4\n\n\nOn utilise [], [[]] ou $ pour extraire les élements d’une liste\n\ny[1]; y[[2]][[1]]\n\n[[1]]\n[1] 1\n\n\n[1] TRUE\n\n\n\n\nLes Dataframes\nL”objet dataframe un type de table ayant des colonnes et des lignes. À la différence d’une matrice, un dataframe peut contenir à la fois des plusieurs types de données. Pour créer un dataframe on utile la fonction data.frame() en précisant le nom des variables.\n\nset.seed(100)\nhead(Produits&lt;-data.frame(ID=1:100, Categories=sample(LETTERS, 100, replace = T), Pays=sample(c(\"Chine\",\"Inde\",\"USA\",\"Canada\",\"Togo\",\"Cameroun\"), 100, replace=T),Prix=runif(100)*100,Quantite=runif(100, min=1, max=100)),3)\n\n  ID Categories   Pays     Prix  Quantite\n1  1          J Canada 61.71091 98.509405\n2  2          W  Chine 79.13045  3.111743\n3  3          F   Inde 33.80487 11.646358\n\n\n\n\nQuelques Opérations sur un data.frame\n\nSelection d’un variable\n\n\nProduits[[\"Pays\"]]\n\n  [1] \"Canada\"   \"Chine\"    \"Inde\"     \"USA\"      \"USA\"      \"USA\"     \n  [7] \"Inde\"     \"Inde\"     \"Chine\"    \"Cameroun\" \"Togo\"     \"Cameroun\"\n [13] \"USA\"      \"Inde\"     \"USA\"      \"Inde\"     \"USA\"      \"Canada\"  \n [19] \"Inde\"     \"Togo\"     \"Cameroun\" \"Chine\"    \"Canada\"   \"Cameroun\"\n [25] \"Cameroun\" \"Inde\"     \"USA\"      \"Cameroun\" \"Inde\"     \"Cameroun\"\n [31] \"USA\"      \"USA\"      \"Canada\"   \"Chine\"    \"Inde\"     \"Cameroun\"\n [37] \"Inde\"     \"Canada\"   \"Canada\"   \"Togo\"     \"Canada\"   \"Togo\"    \n [43] \"Inde\"     \"Canada\"   \"Canada\"   \"Chine\"    \"Inde\"     \"USA\"     \n [49] \"Cameroun\" \"Togo\"     \"Chine\"    \"Canada\"   \"Chine\"    \"Inde\"    \n [55] \"Inde\"     \"Togo\"     \"Cameroun\" \"Inde\"     \"Chine\"    \"Inde\"    \n [61] \"Chine\"    \"Canada\"   \"Inde\"     \"USA\"      \"Cameroun\" \"Inde\"    \n [67] \"Chine\"    \"Inde\"     \"Chine\"    \"Togo\"     \"Chine\"    \"Togo\"    \n [73] \"Cameroun\" \"USA\"      \"Canada\"   \"Inde\"     \"Cameroun\" \"Inde\"    \n [79] \"Inde\"     \"Canada\"   \"Canada\"   \"Inde\"     \"Togo\"     \"Inde\"    \n [85] \"Cameroun\" \"Cameroun\" \"Chine\"    \"Togo\"     \"Canada\"   \"USA\"     \n [91] \"Togo\"     \"Cameroun\" \"Canada\"   \"Cameroun\" \"Togo\"     \"Canada\"  \n [97] \"Cameroun\" \"Chine\"    \"Togo\"     \"Canada\"  \n\n\n\nCreation de nouvelle variable\n\n\nProduits[[\"Valeur\"]]&lt;-Produits[[\"Prix\"]]*Produits[[\"Quantite\"]]\nhead(Produits)\n\n  ID Categories   Pays     Prix  Quantite    Valeur\n1  1          J Canada 61.71091 98.509405 6079.1052\n2  2          W  Chine 79.13045  3.111743  246.2336\n3  3          F   Inde 33.80487 11.646358  393.7036\n4  4          P    USA 90.54476 25.237856 2285.1556\n5  5          S    USA 19.75567 72.513878 1432.5603\n6  6          Y    USA 79.40852  4.240759  336.7524\n\n\n\nrow.names(Produits)\n\n  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"5\"   \"6\"   \"7\"   \"8\"   \"9\"   \"10\"  \"11\"  \"12\" \n [13] \"13\"  \"14\"  \"15\"  \"16\"  \"17\"  \"18\"  \"19\"  \"20\"  \"21\"  \"22\"  \"23\"  \"24\" \n [25] \"25\"  \"26\"  \"27\"  \"28\"  \"29\"  \"30\"  \"31\"  \"32\"  \"33\"  \"34\"  \"35\"  \"36\" \n [37] \"37\"  \"38\"  \"39\"  \"40\"  \"41\"  \"42\"  \"43\"  \"44\"  \"45\"  \"46\"  \"47\"  \"48\" \n [49] \"49\"  \"50\"  \"51\"  \"52\"  \"53\"  \"54\"  \"55\"  \"56\"  \"57\"  \"58\"  \"59\"  \"60\" \n [61] \"61\"  \"62\"  \"63\"  \"64\"  \"65\"  \"66\"  \"67\"  \"68\"  \"69\"  \"70\"  \"71\"  \"72\" \n [73] \"73\"  \"74\"  \"75\"  \"76\"  \"77\"  \"78\"  \"79\"  \"80\"  \"81\"  \"82\"  \"83\"  \"84\" \n [85] \"85\"  \"86\"  \"87\"  \"88\"  \"89\"  \"90\"  \"91\"  \"92\"  \"93\"  \"94\"  \"95\"  \"96\" \n [97] \"97\"  \"98\"  \"99\"  \"100\"\n\n\n\ncolnames(Produits)\n\n[1] \"ID\"         \"Categories\" \"Pays\"       \"Prix\"       \"Quantite\"  \n[6] \"Valeur\"    \n\n\n\nRenommer une variable\n\n\ncolnames(Produits)[2]&lt;-\"Pays de production\"\n\ncolnames(Produits)\n\n[1] \"ID\"                 \"Pays de production\" \"Pays\"              \n[4] \"Prix\"               \"Quantite\"           \"Valeur\"            \n\n\n\nattach() ou detach() La fonction attach() appliquée à un dataframe permet de rendre visible les variables du dataframe\n\n\nattach(Produits)\n\n\nsummary(Prix); summary(Valeur)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.632  33.627  54.632  53.707  74.508  99.601 \n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   56.1   987.8  2138.8  2740.3  4036.4  9204.4 \n\n\nLa fonction detach() appliquée à un dataframe supprime la visibilité des variables.\n\ndetach(Produits)"
  },
  {
    "objectID": "stringmanip.html",
    "href": "stringmanip.html",
    "title": "Expression régulière",
    "section": "",
    "text": "Dans cette section nous aborderons les fonctions suivantes:\n\ngrep() et grepl(): La fonction grep() recherche les correspondances d’une expression régulière dans un vecteur de chaines de caractères. Elle retourne l’indice du caractère dans le vecteur.\n\n\nlibrary(stringr)\nx&lt;-c(\"R\",\"est\",\"l'outil\",\"des\",\"scientiques\",\"des données\")\ngrep(\"[t-z]\",x)\n\n[1] 2 3 5\n\n\nLa fonction grepl() est similaire à grep() mais retourne des vecteurs logiques.\n\ngrepl(\"[t-z]\",x)\n\n[1] FALSE  TRUE  TRUE FALSE  TRUE FALSE\n\n\n\nregexpr() et gregexpr()\n\nLa fonction regexpr() recherche une chaine de caractères dans un text et retourne un vecteur comprenant renseignant la longueur de la chaine contenant l’élément recherché. Si la chaine n’est pas trouvée, elle retourne -1.\n\nregexpr(\"es\", x)\n\n[1] -1  1 -1  2 10  2\nattr(,\"match.length\")\n[1] -1  2 -1  2  2  2\n\n\nLa fonction gregexpr() retourne une liste comprenant renseignant la longueur de la chaine contenant l’élément recherché. Si la chaine n’est pas trouvée, elle retourne -1.\n\ngregexpr(\"es\", x)[[1]]\n\n[1] -1\nattr(,\"match.length\")\n[1] -1\n\n\n\nsub() et gsub() La fonction sub() substitue un caractère ou chaine de caractére par un autre défini par l’utilisateur. Mais s’il y a plusieurs caratères à trouver, elle ne remplace que le premier\n\n\ndate&lt;-\"17 12 2023\"\nsub(\"\\\\s\", \"-\", date)\n\n[1] \"17-12 2023\"\n\n\nLa fonction gsub() par contre remplace tous les caractères à trouver.\n\ndate&lt;-\"17 12 2023\"\ngsub(\"\\\\s\", \"-\", date)\n\n[1] \"17-12-2023\"\n\n\n\nregexec()\n\nregexec() renvoie une liste de la même longueur que le texte. Les éléments sont soit -1 si le caractère recherché n’a pas de correspondant ou soit une séquence d’entiers avec la positions de départ du caractère retrouvé et toutes les sous-chaînes correspondant aux sous-expressions entre parenthèses.\n\nx&lt;-\"https://regex101.com/\"\nr&lt;-regexec(\"(([^:]+)://)?([^:/]+)\",x )\nr\n\n[[1]]\n[1] 1 1 1 9\nattr(,\"match.length\")\n[1] 20  8  5 12\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE"
  },
  {
    "objectID": "stringmanip.html#manipulation-des-chaines-de-caractères",
    "href": "stringmanip.html#manipulation-des-chaines-de-caractères",
    "title": "Expression régulière",
    "section": "",
    "text": "Dans cette section nous aborderons les fonctions suivantes:\n\ngrep() et grepl(): La fonction grep() recherche les correspondances d’une expression régulière dans un vecteur de chaines de caractères. Elle retourne l’indice du caractère dans le vecteur.\n\n\nlibrary(stringr)\nx&lt;-c(\"R\",\"est\",\"l'outil\",\"des\",\"scientiques\",\"des données\")\ngrep(\"[t-z]\",x)\n\n[1] 2 3 5\n\n\nLa fonction grepl() est similaire à grep() mais retourne des vecteurs logiques.\n\ngrepl(\"[t-z]\",x)\n\n[1] FALSE  TRUE  TRUE FALSE  TRUE FALSE\n\n\n\nregexpr() et gregexpr()\n\nLa fonction regexpr() recherche une chaine de caractères dans un text et retourne un vecteur comprenant renseignant la longueur de la chaine contenant l’élément recherché. Si la chaine n’est pas trouvée, elle retourne -1.\n\nregexpr(\"es\", x)\n\n[1] -1  1 -1  2 10  2\nattr(,\"match.length\")\n[1] -1  2 -1  2  2  2\n\n\nLa fonction gregexpr() retourne une liste comprenant renseignant la longueur de la chaine contenant l’élément recherché. Si la chaine n’est pas trouvée, elle retourne -1.\n\ngregexpr(\"es\", x)[[1]]\n\n[1] -1\nattr(,\"match.length\")\n[1] -1\n\n\n\nsub() et gsub() La fonction sub() substitue un caractère ou chaine de caractére par un autre défini par l’utilisateur. Mais s’il y a plusieurs caratères à trouver, elle ne remplace que le premier\n\n\ndate&lt;-\"17 12 2023\"\nsub(\"\\\\s\", \"-\", date)\n\n[1] \"17-12 2023\"\n\n\nLa fonction gsub() par contre remplace tous les caractères à trouver.\n\ndate&lt;-\"17 12 2023\"\ngsub(\"\\\\s\", \"-\", date)\n\n[1] \"17-12-2023\"\n\n\n\nregexec()\n\nregexec() renvoie une liste de la même longueur que le texte. Les éléments sont soit -1 si le caractère recherché n’a pas de correspondant ou soit une séquence d’entiers avec la positions de départ du caractère retrouvé et toutes les sous-chaînes correspondant aux sous-expressions entre parenthèses.\n\nx&lt;-\"https://regex101.com/\"\nr&lt;-regexec(\"(([^:]+)://)?([^:/]+)\",x )\nr\n\n[[1]]\n[1] 1 1 1 9\nattr(,\"match.length\")\n[1] 20  8  5 12\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE"
  },
  {
    "objectID": "stringmanip.html#expressions-régulières",
    "href": "stringmanip.html#expressions-régulières",
    "title": "Expression régulière",
    "section": "Expressions régulières",
    "text": "Expressions régulières\nJe vous invite à consulter de temps en temps le site regex si vous êtes bloqués.\n\nUtilisation de l’extraction par groupe avec les fonctions str_match et str_extract\n\n\nExemple\n\nstrings &lt;- c(\" 219 733 8965\", \"329-293-8753 \", \"banana\", \"595 794 7569\",\n  \"387 287 6718\", \"apple\", \"233.398.9187  \", \"482 952 3315\",\n  \"239 923 8115 and 842 566 4692\", \"Work: 579-499-7527\", \"$1000\",\n  \"Home: 543.355.3679\")\nphone &lt;- \"(\\\\d{3})[- .](\\\\d{3})[- .](\\\\d{4})\"\n\n\n\nstr_match\n\nstr_match(strings, phone)\n\n      [,1]           [,2]  [,3]  [,4]  \n [1,] \"219 733 8965\" \"219\" \"733\" \"8965\"\n [2,] \"329-293-8753\" \"329\" \"293\" \"8753\"\n [3,] NA             NA    NA    NA    \n [4,] \"595 794 7569\" \"595\" \"794\" \"7569\"\n [5,] \"387 287 6718\" \"387\" \"287\" \"6718\"\n [6,] NA             NA    NA    NA    \n [7,] \"233.398.9187\" \"233\" \"398\" \"9187\"\n [8,] \"482 952 3315\" \"482\" \"952\" \"3315\"\n [9,] \"239 923 8115\" \"239\" \"923\" \"8115\"\n[10,] \"579-499-7527\" \"579\" \"499\" \"7527\"\n[11,] NA             NA    NA    NA    \n[12,] \"543.355.3679\" \"543\" \"355\" \"3679\"\n\n\n\n\nstr_extract\n\nstr_extract(strings, phone)\n\n [1] \"219 733 8965\" \"329-293-8753\" NA             \"595 794 7569\" \"387 287 6718\"\n [6] NA             \"233.398.9187\" \"482 952 3315\" \"239 923 8115\" \"579-499-7527\"\n[11] NA             \"543.355.3679\"\n\n\n\n\nMatch en groupe\n\nphone&lt;-\"(?&lt;zone&gt;\\\\d{3})[- .](?&lt;phone&gt;\\\\d{3}[- .]\\\\d{4})\"\nstr_match(strings, phone)\n\n                     zone  phone     \n [1,] \"219 733 8965\" \"219\" \"733 8965\"\n [2,] \"329-293-8753\" \"329\" \"293-8753\"\n [3,] NA             NA    NA        \n [4,] \"595 794 7569\" \"595\" \"794 7569\"\n [5,] \"387 287 6718\" \"387\" \"287 6718\"\n [6,] NA             NA    NA        \n [7,] \"233.398.9187\" \"233\" \"398.9187\"\n [8,] \"482 952 3315\" \"482\" \"952 3315\"\n [9,] \"239 923 8115\" \"239\" \"923 8115\"\n[10,] \"579-499-7527\" \"579\" \"499-7527\"\n[11,] NA             NA    NA        \n[12,] \"543.355.3679\" \"543\" \"355.3679\"\n\n\n\n\n\n\n\n\nExercice\n\n\n\nNous allons dans cet exercice manipuler les données l’immigration Canada relative aux résidents permanents. Travail à faire: - Importer ce fichier suivant “https://www.ircc.canada.ca/opendata-donneesouvertes/data/EN_ODP-PR-ProvImmCat.xlsx”\n\nQu’est ce que vous remarquez?\nUtiliser la fonction str_remove_all() pour enlever cette chaine de caractère ‘xml:space=“preserve”&gt;’\nUtiliser la fonction select() avec where() pour retenir les colonnes pertinentes - Utiliser la fonction mutate() pour créer une ligne de contenant les dates.\nDefinir la lignes des dates comme variables\nUtiliser la fonction mutate() pour imputer les variables manquantes."
  }
]